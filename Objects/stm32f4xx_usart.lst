ARM GAS  /tmp/cc0JzPHi.s 			page 1


   1              		.cpu cortex-m4
   2              		.eabi_attribute 27, 1
   3              		.eabi_attribute 28, 1
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 1
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.file	"stm32f4xx_usart.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.section	.text.USART_DeInit,"ax",%progbits
  18              		.align	1
  19              		.global	USART_DeInit
  20              		.syntax unified
  21              		.thumb
  22              		.thumb_func
  23              		.fpu fpv4-sp-d16
  25              	USART_DeInit:
  26              	.LFB123:
  27              		.file 1 "FWLIB/src/stm32f4xx_usart.c"
   1:FWLIB/src/stm32f4xx_usart.c **** /**
   2:FWLIB/src/stm32f4xx_usart.c ****   ******************************************************************************
   3:FWLIB/src/stm32f4xx_usart.c ****   * @file    stm32f4xx_usart.c
   4:FWLIB/src/stm32f4xx_usart.c ****   * @author  MCD Application Team
   5:FWLIB/src/stm32f4xx_usart.c ****   * @version V1.8.0
   6:FWLIB/src/stm32f4xx_usart.c ****   * @date    04-November-2016
   7:FWLIB/src/stm32f4xx_usart.c ****   * @brief   This file provides firmware functions to manage the following 
   8:FWLIB/src/stm32f4xx_usart.c ****   *          functionalities of the Universal synchronous asynchronous receiver
   9:FWLIB/src/stm32f4xx_usart.c ****   *          transmitter (USART):           
  10:FWLIB/src/stm32f4xx_usart.c ****   *           + Initialization and Configuration
  11:FWLIB/src/stm32f4xx_usart.c ****   *           + Data transfers
  12:FWLIB/src/stm32f4xx_usart.c ****   *           + Multi-Processor Communication
  13:FWLIB/src/stm32f4xx_usart.c ****   *           + LIN mode
  14:FWLIB/src/stm32f4xx_usart.c ****   *           + Half-duplex mode
  15:FWLIB/src/stm32f4xx_usart.c ****   *           + Smartcard mode
  16:FWLIB/src/stm32f4xx_usart.c ****   *           + IrDA mode
  17:FWLIB/src/stm32f4xx_usart.c ****   *           + DMA transfers management
  18:FWLIB/src/stm32f4xx_usart.c ****   *           + Interrupts and flags management 
  19:FWLIB/src/stm32f4xx_usart.c ****   *           
  20:FWLIB/src/stm32f4xx_usart.c ****   @verbatim       
  21:FWLIB/src/stm32f4xx_usart.c ****  ===============================================================================
  22:FWLIB/src/stm32f4xx_usart.c ****                         ##### How to use this driver #####
  23:FWLIB/src/stm32f4xx_usart.c ****  ===============================================================================
  24:FWLIB/src/stm32f4xx_usart.c ****     [..]
  25:FWLIB/src/stm32f4xx_usart.c ****       (#) Enable peripheral clock using the following functions
  26:FWLIB/src/stm32f4xx_usart.c ****           RCC_APB2PeriphClockCmd(RCC_APB2Periph_USARTx, ENABLE) for USART1 and USART6 
  27:FWLIB/src/stm32f4xx_usart.c ****           RCC_APB1PeriphClockCmd(RCC_APB1Periph_USARTx, ENABLE) for USART2, USART3, 
  28:FWLIB/src/stm32f4xx_usart.c ****           UART4 or UART5.
  29:FWLIB/src/stm32f4xx_usart.c ****   
  30:FWLIB/src/stm32f4xx_usart.c ****       (#) According to the USART mode, enable the GPIO clocks using 
  31:FWLIB/src/stm32f4xx_usart.c ****           RCC_AHB1PeriphClockCmd() function. (The I/O can be TX, RX, CTS, 
ARM GAS  /tmp/cc0JzPHi.s 			page 2


  32:FWLIB/src/stm32f4xx_usart.c ****           or/and SCLK). 
  33:FWLIB/src/stm32f4xx_usart.c ****   
  34:FWLIB/src/stm32f4xx_usart.c ****       (#) Peripheral's alternate function: 
  35:FWLIB/src/stm32f4xx_usart.c ****         (++) Connect the pin to the desired peripherals' Alternate 
  36:FWLIB/src/stm32f4xx_usart.c ****             Function (AF) using GPIO_PinAFConfig() function
  37:FWLIB/src/stm32f4xx_usart.c ****         (++) Configure the desired pin in alternate function by:
  38:FWLIB/src/stm32f4xx_usart.c ****             GPIO_InitStruct->GPIO_Mode = GPIO_Mode_AF
  39:FWLIB/src/stm32f4xx_usart.c ****         (++) Select the type, pull-up/pull-down and output speed via 
  40:FWLIB/src/stm32f4xx_usart.c ****             GPIO_PuPd, GPIO_OType and GPIO_Speed members
  41:FWLIB/src/stm32f4xx_usart.c ****         (++) Call GPIO_Init() function
  42:FWLIB/src/stm32f4xx_usart.c ****           
  43:FWLIB/src/stm32f4xx_usart.c ****       (#) Program the Baud Rate, Word Length , Stop Bit, Parity, Hardware 
  44:FWLIB/src/stm32f4xx_usart.c ****           flow control and Mode(Receiver/Transmitter) using the USART_Init()
  45:FWLIB/src/stm32f4xx_usart.c ****           function.
  46:FWLIB/src/stm32f4xx_usart.c ****   
  47:FWLIB/src/stm32f4xx_usart.c ****       (#) For synchronous mode, enable the clock and program the polarity,
  48:FWLIB/src/stm32f4xx_usart.c ****           phase and last bit using the USART_ClockInit() function.
  49:FWLIB/src/stm32f4xx_usart.c ****   
  50:FWLIB/src/stm32f4xx_usart.c ****       (#) Enable the NVIC and the corresponding interrupt using the function 
  51:FWLIB/src/stm32f4xx_usart.c ****          USART_ITConfig() if you need to use interrupt mode. 
  52:FWLIB/src/stm32f4xx_usart.c ****   
  53:FWLIB/src/stm32f4xx_usart.c ****       (#) When using the DMA mode 
  54:FWLIB/src/stm32f4xx_usart.c ****         (++) Configure the DMA using DMA_Init() function
  55:FWLIB/src/stm32f4xx_usart.c ****         (++) Active the needed channel Request using USART_DMACmd() function
  56:FWLIB/src/stm32f4xx_usart.c ****    
  57:FWLIB/src/stm32f4xx_usart.c ****       (#) Enable the USART using the USART_Cmd() function.
  58:FWLIB/src/stm32f4xx_usart.c ****    
  59:FWLIB/src/stm32f4xx_usart.c ****       (#) Enable the DMA using the DMA_Cmd() function, when using DMA mode. 
  60:FWLIB/src/stm32f4xx_usart.c ****     
  61:FWLIB/src/stm32f4xx_usart.c ****       -@- Refer to Multi-Processor, LIN, half-duplex, Smartcard, IrDA sub-sections
  62:FWLIB/src/stm32f4xx_usart.c ****           for more details
  63:FWLIB/src/stm32f4xx_usart.c ****     
  64:FWLIB/src/stm32f4xx_usart.c ****     [..]        
  65:FWLIB/src/stm32f4xx_usart.c ****     In order to reach higher communication baudrates, it is possible to
  66:FWLIB/src/stm32f4xx_usart.c ****     enable the oversampling by 8 mode using the function USART_OverSampling8Cmd().
  67:FWLIB/src/stm32f4xx_usart.c ****     This function should be called after enabling the USART clock (RCC_APBxPeriphClockCmd())
  68:FWLIB/src/stm32f4xx_usart.c ****     and before calling the function USART_Init().
  69:FWLIB/src/stm32f4xx_usart.c ****             
  70:FWLIB/src/stm32f4xx_usart.c ****     @endverbatim        
  71:FWLIB/src/stm32f4xx_usart.c ****   ******************************************************************************
  72:FWLIB/src/stm32f4xx_usart.c ****   * @attention
  73:FWLIB/src/stm32f4xx_usart.c ****   *
  74:FWLIB/src/stm32f4xx_usart.c ****   * <h2><center>&copy; COPYRIGHT 2016 STMicroelectronics</center></h2>
  75:FWLIB/src/stm32f4xx_usart.c ****   *
  76:FWLIB/src/stm32f4xx_usart.c ****   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
  77:FWLIB/src/stm32f4xx_usart.c ****   * You may not use this file except in compliance with the License.
  78:FWLIB/src/stm32f4xx_usart.c ****   * You may obtain a copy of the License at:
  79:FWLIB/src/stm32f4xx_usart.c ****   *
  80:FWLIB/src/stm32f4xx_usart.c ****   *        http://www.st.com/software_license_agreement_liberty_v2
  81:FWLIB/src/stm32f4xx_usart.c ****   *
  82:FWLIB/src/stm32f4xx_usart.c ****   * Unless required by applicable law or agreed to in writing, software 
  83:FWLIB/src/stm32f4xx_usart.c ****   * distributed under the License is distributed on an "AS IS" BASIS, 
  84:FWLIB/src/stm32f4xx_usart.c ****   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  85:FWLIB/src/stm32f4xx_usart.c ****   * See the License for the specific language governing permissions and
  86:FWLIB/src/stm32f4xx_usart.c ****   * limitations under the License.
  87:FWLIB/src/stm32f4xx_usart.c ****   *
  88:FWLIB/src/stm32f4xx_usart.c ****   ******************************************************************************  
ARM GAS  /tmp/cc0JzPHi.s 			page 3


  89:FWLIB/src/stm32f4xx_usart.c ****   */ 
  90:FWLIB/src/stm32f4xx_usart.c **** 
  91:FWLIB/src/stm32f4xx_usart.c **** /* Includes ------------------------------------------------------------------*/
  92:FWLIB/src/stm32f4xx_usart.c **** #include "stm32f4xx_usart.h"
  93:FWLIB/src/stm32f4xx_usart.c **** #include "stm32f4xx_rcc.h"
  94:FWLIB/src/stm32f4xx_usart.c **** 
  95:FWLIB/src/stm32f4xx_usart.c **** /** @addtogroup STM32F4xx_StdPeriph_Driver
  96:FWLIB/src/stm32f4xx_usart.c ****   * @{
  97:FWLIB/src/stm32f4xx_usart.c ****   */
  98:FWLIB/src/stm32f4xx_usart.c **** 
  99:FWLIB/src/stm32f4xx_usart.c **** /** @defgroup USART 
 100:FWLIB/src/stm32f4xx_usart.c ****   * @brief USART driver modules
 101:FWLIB/src/stm32f4xx_usart.c ****   * @{
 102:FWLIB/src/stm32f4xx_usart.c ****   */
 103:FWLIB/src/stm32f4xx_usart.c **** 
 104:FWLIB/src/stm32f4xx_usart.c **** /* Private typedef -----------------------------------------------------------*/
 105:FWLIB/src/stm32f4xx_usart.c **** /* Private define ------------------------------------------------------------*/
 106:FWLIB/src/stm32f4xx_usart.c **** 
 107:FWLIB/src/stm32f4xx_usart.c **** /*!< USART CR1 register clear Mask ((~(uint16_t)0xE9F3)) */
 108:FWLIB/src/stm32f4xx_usart.c **** #define CR1_CLEAR_MASK            ((uint16_t)(USART_CR1_M | USART_CR1_PCE | \
 109:FWLIB/src/stm32f4xx_usart.c ****                                               USART_CR1_PS | USART_CR1_TE | \
 110:FWLIB/src/stm32f4xx_usart.c ****                                               USART_CR1_RE))
 111:FWLIB/src/stm32f4xx_usart.c **** 
 112:FWLIB/src/stm32f4xx_usart.c **** /*!< USART CR2 register clock bits clear Mask ((~(uint16_t)0xF0FF)) */
 113:FWLIB/src/stm32f4xx_usart.c **** #define CR2_CLOCK_CLEAR_MASK      ((uint16_t)(USART_CR2_CLKEN | USART_CR2_CPOL | \
 114:FWLIB/src/stm32f4xx_usart.c ****                                               USART_CR2_CPHA | USART_CR2_LBCL))
 115:FWLIB/src/stm32f4xx_usart.c **** 
 116:FWLIB/src/stm32f4xx_usart.c **** /*!< USART CR3 register clear Mask ((~(uint16_t)0xFCFF)) */
 117:FWLIB/src/stm32f4xx_usart.c **** #define CR3_CLEAR_MASK            ((uint16_t)(USART_CR3_RTSE | USART_CR3_CTSE))
 118:FWLIB/src/stm32f4xx_usart.c **** 
 119:FWLIB/src/stm32f4xx_usart.c **** /*!< USART Interrupts mask */
 120:FWLIB/src/stm32f4xx_usart.c **** #define IT_MASK                   ((uint16_t)0x001F)
 121:FWLIB/src/stm32f4xx_usart.c **** 
 122:FWLIB/src/stm32f4xx_usart.c **** /* Private macro -------------------------------------------------------------*/
 123:FWLIB/src/stm32f4xx_usart.c **** /* Private variables ---------------------------------------------------------*/
 124:FWLIB/src/stm32f4xx_usart.c **** /* Private function prototypes -----------------------------------------------*/
 125:FWLIB/src/stm32f4xx_usart.c **** /* Private functions ---------------------------------------------------------*/
 126:FWLIB/src/stm32f4xx_usart.c **** 
 127:FWLIB/src/stm32f4xx_usart.c **** /** @defgroup USART_Private_Functions
 128:FWLIB/src/stm32f4xx_usart.c ****   * @{
 129:FWLIB/src/stm32f4xx_usart.c ****   */
 130:FWLIB/src/stm32f4xx_usart.c **** 
 131:FWLIB/src/stm32f4xx_usart.c **** /** @defgroup USART_Group1 Initialization and Configuration functions
 132:FWLIB/src/stm32f4xx_usart.c ****  *  @brief   Initialization and Configuration functions 
 133:FWLIB/src/stm32f4xx_usart.c ****  *
 134:FWLIB/src/stm32f4xx_usart.c **** @verbatim   
 135:FWLIB/src/stm32f4xx_usart.c ****  ===============================================================================
 136:FWLIB/src/stm32f4xx_usart.c ****             ##### Initialization and Configuration functions #####
 137:FWLIB/src/stm32f4xx_usart.c ****  ===============================================================================  
 138:FWLIB/src/stm32f4xx_usart.c ****     [..]
 139:FWLIB/src/stm32f4xx_usart.c ****     This subsection provides a set of functions allowing to initialize the USART 
 140:FWLIB/src/stm32f4xx_usart.c ****     in asynchronous and in synchronous modes.
 141:FWLIB/src/stm32f4xx_usart.c ****       (+) For the asynchronous mode only these parameters can be configured: 
 142:FWLIB/src/stm32f4xx_usart.c ****         (++) Baud Rate
 143:FWLIB/src/stm32f4xx_usart.c ****         (++) Word Length 
 144:FWLIB/src/stm32f4xx_usart.c ****         (++) Stop Bit
 145:FWLIB/src/stm32f4xx_usart.c ****         (++) Parity: If the parity is enabled, then the MSB bit of the data written
ARM GAS  /tmp/cc0JzPHi.s 			page 4


 146:FWLIB/src/stm32f4xx_usart.c ****              in the data register is transmitted but is changed by the parity bit.
 147:FWLIB/src/stm32f4xx_usart.c ****              Depending on the frame length defined by the M bit (8-bits or 9-bits),
 148:FWLIB/src/stm32f4xx_usart.c ****              the possible USART frame formats are as listed in the following table:
 149:FWLIB/src/stm32f4xx_usart.c ****    +-------------------------------------------------------------+     
 150:FWLIB/src/stm32f4xx_usart.c ****    |   M bit |  PCE bit  |            USART frame                |
 151:FWLIB/src/stm32f4xx_usart.c ****    |---------------------|---------------------------------------|             
 152:FWLIB/src/stm32f4xx_usart.c ****    |    0    |    0      |    | SB | 8 bit data | STB |          |
 153:FWLIB/src/stm32f4xx_usart.c ****    |---------|-----------|---------------------------------------|  
 154:FWLIB/src/stm32f4xx_usart.c ****    |    0    |    1      |    | SB | 7 bit data | PB | STB |     |
 155:FWLIB/src/stm32f4xx_usart.c ****    |---------|-----------|---------------------------------------|  
 156:FWLIB/src/stm32f4xx_usart.c ****    |    1    |    0      |    | SB | 9 bit data | STB |          |
 157:FWLIB/src/stm32f4xx_usart.c ****    |---------|-----------|---------------------------------------|  
 158:FWLIB/src/stm32f4xx_usart.c ****    |    1    |    1      |    | SB | 8 bit data | PB | STB |     |
 159:FWLIB/src/stm32f4xx_usart.c ****    +-------------------------------------------------------------+            
 160:FWLIB/src/stm32f4xx_usart.c ****         (++) Hardware flow control
 161:FWLIB/src/stm32f4xx_usart.c ****         (++) Receiver/transmitter modes
 162:FWLIB/src/stm32f4xx_usart.c **** 
 163:FWLIB/src/stm32f4xx_usart.c ****     [..]
 164:FWLIB/src/stm32f4xx_usart.c ****     The USART_Init() function follows the USART  asynchronous configuration 
 165:FWLIB/src/stm32f4xx_usart.c ****     procedure (details for the procedure are available in reference manual (RM0090)).
 166:FWLIB/src/stm32f4xx_usart.c **** 
 167:FWLIB/src/stm32f4xx_usart.c ****      (+) For the synchronous mode in addition to the asynchronous mode parameters these 
 168:FWLIB/src/stm32f4xx_usart.c ****          parameters should be also configured:
 169:FWLIB/src/stm32f4xx_usart.c ****         (++) USART Clock Enabled
 170:FWLIB/src/stm32f4xx_usart.c ****         (++) USART polarity
 171:FWLIB/src/stm32f4xx_usart.c ****         (++) USART phase
 172:FWLIB/src/stm32f4xx_usart.c ****         (++) USART LastBit
 173:FWLIB/src/stm32f4xx_usart.c ****   
 174:FWLIB/src/stm32f4xx_usart.c ****     [..]
 175:FWLIB/src/stm32f4xx_usart.c ****     These parameters can be configured using the USART_ClockInit() function.
 176:FWLIB/src/stm32f4xx_usart.c **** 
 177:FWLIB/src/stm32f4xx_usart.c **** @endverbatim
 178:FWLIB/src/stm32f4xx_usart.c ****   * @{
 179:FWLIB/src/stm32f4xx_usart.c ****   */
 180:FWLIB/src/stm32f4xx_usart.c ****   
 181:FWLIB/src/stm32f4xx_usart.c **** /**
 182:FWLIB/src/stm32f4xx_usart.c ****   * @brief  Deinitializes the USARTx peripheral registers to their default reset values.
 183:FWLIB/src/stm32f4xx_usart.c ****   * @param  USARTx: where x can be 1, 2, 3, 4, 5, 6, 7 or 8 to select the USART or 
 184:FWLIB/src/stm32f4xx_usart.c ****   *         UART peripheral.
 185:FWLIB/src/stm32f4xx_usart.c ****   * @retval None
 186:FWLIB/src/stm32f4xx_usart.c ****   */
 187:FWLIB/src/stm32f4xx_usart.c **** void USART_DeInit(USART_TypeDef* USARTx)
 188:FWLIB/src/stm32f4xx_usart.c **** {
  28              		.loc 1 188 0
  29              		.cfi_startproc
  30              		@ args = 0, pretend = 0, frame = 0
  31              		@ frame_needed = 0, uses_anonymous_args = 0
  32              	.LVL0:
  33 0000 08B5     		push	{r3, lr}
  34              	.LCFI0:
  35              		.cfi_def_cfa_offset 8
  36              		.cfi_offset 3, -8
  37              		.cfi_offset 14, -4
 189:FWLIB/src/stm32f4xx_usart.c ****   /* Check the parameters */
 190:FWLIB/src/stm32f4xx_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 191:FWLIB/src/stm32f4xx_usart.c **** 
 192:FWLIB/src/stm32f4xx_usart.c ****   if (USARTx == USART1)
ARM GAS  /tmp/cc0JzPHi.s 			page 5


  38              		.loc 1 192 0
  39 0002 364B     		ldr	r3, .L19
  40 0004 9842     		cmp	r0, r3
  41 0006 15D0     		beq	.L11
 193:FWLIB/src/stm32f4xx_usart.c ****   {
 194:FWLIB/src/stm32f4xx_usart.c ****     RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, ENABLE);
 195:FWLIB/src/stm32f4xx_usart.c ****     RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, DISABLE);
 196:FWLIB/src/stm32f4xx_usart.c ****   }
 197:FWLIB/src/stm32f4xx_usart.c ****   else if (USARTx == USART2)
  42              		.loc 1 197 0
  43 0008 354B     		ldr	r3, .L19+4
  44 000a 9842     		cmp	r0, r3
  45 000c 1BD0     		beq	.L12
 198:FWLIB/src/stm32f4xx_usart.c ****   {
 199:FWLIB/src/stm32f4xx_usart.c ****     RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, ENABLE);
 200:FWLIB/src/stm32f4xx_usart.c ****     RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, DISABLE);
 201:FWLIB/src/stm32f4xx_usart.c ****   }
 202:FWLIB/src/stm32f4xx_usart.c ****   else if (USARTx == USART3)
  46              		.loc 1 202 0
  47 000e 354B     		ldr	r3, .L19+8
  48 0010 9842     		cmp	r0, r3
  49 0012 23D0     		beq	.L13
 203:FWLIB/src/stm32f4xx_usart.c ****   {
 204:FWLIB/src/stm32f4xx_usart.c ****     RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, ENABLE);
 205:FWLIB/src/stm32f4xx_usart.c ****     RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, DISABLE);
 206:FWLIB/src/stm32f4xx_usart.c ****   }    
 207:FWLIB/src/stm32f4xx_usart.c ****   else if (USARTx == UART4)
  50              		.loc 1 207 0
  51 0014 344B     		ldr	r3, .L19+12
  52 0016 9842     		cmp	r0, r3
  53 0018 2BD0     		beq	.L14
 208:FWLIB/src/stm32f4xx_usart.c ****   {
 209:FWLIB/src/stm32f4xx_usart.c ****     RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, ENABLE);
 210:FWLIB/src/stm32f4xx_usart.c ****     RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, DISABLE);
 211:FWLIB/src/stm32f4xx_usart.c ****   }
 212:FWLIB/src/stm32f4xx_usart.c ****   else if (USARTx == UART5)
  54              		.loc 1 212 0
  55 001a 344B     		ldr	r3, .L19+16
  56 001c 9842     		cmp	r0, r3
  57 001e 33D0     		beq	.L15
 213:FWLIB/src/stm32f4xx_usart.c ****   {
 214:FWLIB/src/stm32f4xx_usart.c ****     RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, ENABLE);
 215:FWLIB/src/stm32f4xx_usart.c ****     RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, DISABLE);
 216:FWLIB/src/stm32f4xx_usart.c ****   }  
 217:FWLIB/src/stm32f4xx_usart.c ****   else if (USARTx == USART6)
  58              		.loc 1 217 0
  59 0020 334B     		ldr	r3, .L19+20
  60 0022 9842     		cmp	r0, r3
  61 0024 3BD0     		beq	.L16
 218:FWLIB/src/stm32f4xx_usart.c ****   {
 219:FWLIB/src/stm32f4xx_usart.c ****     RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART6, ENABLE);
 220:FWLIB/src/stm32f4xx_usart.c ****     RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART6, DISABLE);
 221:FWLIB/src/stm32f4xx_usart.c ****   }
 222:FWLIB/src/stm32f4xx_usart.c ****   else if (USARTx == UART7)
  62              		.loc 1 222 0
  63 0026 334B     		ldr	r3, .L19+24
  64 0028 9842     		cmp	r0, r3
ARM GAS  /tmp/cc0JzPHi.s 			page 6


  65 002a 41D0     		beq	.L17
 223:FWLIB/src/stm32f4xx_usart.c ****   {
 224:FWLIB/src/stm32f4xx_usart.c ****     RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART7, ENABLE);
 225:FWLIB/src/stm32f4xx_usart.c ****     RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART7, DISABLE);
 226:FWLIB/src/stm32f4xx_usart.c ****   }     
 227:FWLIB/src/stm32f4xx_usart.c ****   else
 228:FWLIB/src/stm32f4xx_usart.c ****   {
 229:FWLIB/src/stm32f4xx_usart.c ****     if (USARTx == UART8)
  66              		.loc 1 229 0
  67 002c 324B     		ldr	r3, .L19+28
  68 002e 9842     		cmp	r0, r3
  69 0030 49D0     		beq	.L18
  70              	.LVL1:
  71              	.L1:
  72 0032 08BD     		pop	{r3, pc}
  73              	.LVL2:
  74              	.L11:
 194:FWLIB/src/stm32f4xx_usart.c ****     RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, DISABLE);
  75              		.loc 1 194 0
  76 0034 0121     		movs	r1, #1
  77 0036 1020     		movs	r0, #16
  78              	.LVL3:
  79 0038 FFF7FEFF 		bl	RCC_APB2PeriphResetCmd
  80              	.LVL4:
 195:FWLIB/src/stm32f4xx_usart.c ****   }
  81              		.loc 1 195 0
  82 003c 0021     		movs	r1, #0
  83 003e 1020     		movs	r0, #16
  84 0040 FFF7FEFF 		bl	RCC_APB2PeriphResetCmd
  85              	.LVL5:
  86 0044 08BD     		pop	{r3, pc}
  87              	.LVL6:
  88              	.L12:
 199:FWLIB/src/stm32f4xx_usart.c ****     RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, DISABLE);
  89              		.loc 1 199 0
  90 0046 0121     		movs	r1, #1
  91 0048 4FF40030 		mov	r0, #131072
  92              	.LVL7:
  93 004c FFF7FEFF 		bl	RCC_APB1PeriphResetCmd
  94              	.LVL8:
 200:FWLIB/src/stm32f4xx_usart.c ****   }
  95              		.loc 1 200 0
  96 0050 0021     		movs	r1, #0
  97 0052 4FF40030 		mov	r0, #131072
  98 0056 FFF7FEFF 		bl	RCC_APB1PeriphResetCmd
  99              	.LVL9:
 100 005a 08BD     		pop	{r3, pc}
 101              	.LVL10:
 102              	.L13:
 204:FWLIB/src/stm32f4xx_usart.c ****     RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, DISABLE);
 103              		.loc 1 204 0
 104 005c 0121     		movs	r1, #1
 105 005e 4FF48020 		mov	r0, #262144
 106              	.LVL11:
 107 0062 FFF7FEFF 		bl	RCC_APB1PeriphResetCmd
 108              	.LVL12:
 205:FWLIB/src/stm32f4xx_usart.c ****   }    
ARM GAS  /tmp/cc0JzPHi.s 			page 7


 109              		.loc 1 205 0
 110 0066 0021     		movs	r1, #0
 111 0068 4FF48020 		mov	r0, #262144
 112 006c FFF7FEFF 		bl	RCC_APB1PeriphResetCmd
 113              	.LVL13:
 114 0070 08BD     		pop	{r3, pc}
 115              	.LVL14:
 116              	.L14:
 209:FWLIB/src/stm32f4xx_usart.c ****     RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, DISABLE);
 117              		.loc 1 209 0
 118 0072 0121     		movs	r1, #1
 119 0074 4FF40020 		mov	r0, #524288
 120              	.LVL15:
 121 0078 FFF7FEFF 		bl	RCC_APB1PeriphResetCmd
 122              	.LVL16:
 210:FWLIB/src/stm32f4xx_usart.c ****   }
 123              		.loc 1 210 0
 124 007c 0021     		movs	r1, #0
 125 007e 4FF40020 		mov	r0, #524288
 126 0082 FFF7FEFF 		bl	RCC_APB1PeriphResetCmd
 127              	.LVL17:
 128 0086 08BD     		pop	{r3, pc}
 129              	.LVL18:
 130              	.L15:
 214:FWLIB/src/stm32f4xx_usart.c ****     RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, DISABLE);
 131              		.loc 1 214 0
 132 0088 0121     		movs	r1, #1
 133 008a 4FF48010 		mov	r0, #1048576
 134              	.LVL19:
 135 008e FFF7FEFF 		bl	RCC_APB1PeriphResetCmd
 136              	.LVL20:
 215:FWLIB/src/stm32f4xx_usart.c ****   }  
 137              		.loc 1 215 0
 138 0092 0021     		movs	r1, #0
 139 0094 4FF48010 		mov	r0, #1048576
 140 0098 FFF7FEFF 		bl	RCC_APB1PeriphResetCmd
 141              	.LVL21:
 142 009c 08BD     		pop	{r3, pc}
 143              	.LVL22:
 144              	.L16:
 219:FWLIB/src/stm32f4xx_usart.c ****     RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART6, DISABLE);
 145              		.loc 1 219 0
 146 009e 0121     		movs	r1, #1
 147 00a0 2020     		movs	r0, #32
 148              	.LVL23:
 149 00a2 FFF7FEFF 		bl	RCC_APB2PeriphResetCmd
 150              	.LVL24:
 220:FWLIB/src/stm32f4xx_usart.c ****   }
 151              		.loc 1 220 0
 152 00a6 0021     		movs	r1, #0
 153 00a8 2020     		movs	r0, #32
 154 00aa FFF7FEFF 		bl	RCC_APB2PeriphResetCmd
 155              	.LVL25:
 156 00ae 08BD     		pop	{r3, pc}
 157              	.LVL26:
 158              	.L17:
 224:FWLIB/src/stm32f4xx_usart.c ****     RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART7, DISABLE);
ARM GAS  /tmp/cc0JzPHi.s 			page 8


 159              		.loc 1 224 0
 160 00b0 0121     		movs	r1, #1
 161 00b2 4FF08040 		mov	r0, #1073741824
 162              	.LVL27:
 163 00b6 FFF7FEFF 		bl	RCC_APB1PeriphResetCmd
 164              	.LVL28:
 225:FWLIB/src/stm32f4xx_usart.c ****   }     
 165              		.loc 1 225 0
 166 00ba 0021     		movs	r1, #0
 167 00bc 4FF08040 		mov	r0, #1073741824
 168 00c0 FFF7FEFF 		bl	RCC_APB1PeriphResetCmd
 169              	.LVL29:
 170 00c4 08BD     		pop	{r3, pc}
 171              	.LVL30:
 172              	.L18:
 230:FWLIB/src/stm32f4xx_usart.c ****     { 
 231:FWLIB/src/stm32f4xx_usart.c ****       RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART8, ENABLE);
 173              		.loc 1 231 0
 174 00c6 0121     		movs	r1, #1
 175 00c8 4FF00040 		mov	r0, #-2147483648
 176              	.LVL31:
 177 00cc FFF7FEFF 		bl	RCC_APB1PeriphResetCmd
 178              	.LVL32:
 232:FWLIB/src/stm32f4xx_usart.c ****       RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART8, DISABLE);
 179              		.loc 1 232 0
 180 00d0 0021     		movs	r1, #0
 181 00d2 4FF00040 		mov	r0, #-2147483648
 182 00d6 FFF7FEFF 		bl	RCC_APB1PeriphResetCmd
 183              	.LVL33:
 233:FWLIB/src/stm32f4xx_usart.c ****     }
 234:FWLIB/src/stm32f4xx_usart.c ****   }
 235:FWLIB/src/stm32f4xx_usart.c **** }
 184              		.loc 1 235 0
 185 00da AAE7     		b	.L1
 186              	.L20:
 187              		.align	2
 188              	.L19:
 189 00dc 00100140 		.word	1073811456
 190 00e0 00440040 		.word	1073759232
 191 00e4 00480040 		.word	1073760256
 192 00e8 004C0040 		.word	1073761280
 193 00ec 00500040 		.word	1073762304
 194 00f0 00140140 		.word	1073812480
 195 00f4 00780040 		.word	1073772544
 196 00f8 007C0040 		.word	1073773568
 197              		.cfi_endproc
 198              	.LFE123:
 200              		.section	.text.USART_Init,"ax",%progbits
 201              		.align	1
 202              		.global	USART_Init
 203              		.syntax unified
 204              		.thumb
 205              		.thumb_func
 206              		.fpu fpv4-sp-d16
 208              	USART_Init:
 209              	.LFB124:
 236:FWLIB/src/stm32f4xx_usart.c **** 
ARM GAS  /tmp/cc0JzPHi.s 			page 9


 237:FWLIB/src/stm32f4xx_usart.c **** /**
 238:FWLIB/src/stm32f4xx_usart.c ****   * @brief  Initializes the USARTx peripheral according to the specified
 239:FWLIB/src/stm32f4xx_usart.c ****   *         parameters in the USART_InitStruct .
 240:FWLIB/src/stm32f4xx_usart.c ****   * @param  USARTx: where x can be 1, 2, 3, 4, 5, 6, 7 or 8 to select the USART or 
 241:FWLIB/src/stm32f4xx_usart.c ****   *         UART peripheral.
 242:FWLIB/src/stm32f4xx_usart.c ****   * @param  USART_InitStruct: pointer to a USART_InitTypeDef structure that contains
 243:FWLIB/src/stm32f4xx_usart.c ****   *         the configuration information for the specified USART peripheral.
 244:FWLIB/src/stm32f4xx_usart.c ****   * @retval None
 245:FWLIB/src/stm32f4xx_usart.c ****   */
 246:FWLIB/src/stm32f4xx_usart.c **** void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)
 247:FWLIB/src/stm32f4xx_usart.c **** {
 210              		.loc 1 247 0
 211              		.cfi_startproc
 212              		@ args = 0, pretend = 0, frame = 16
 213              		@ frame_needed = 0, uses_anonymous_args = 0
 214              	.LVL34:
 215 0000 30B5     		push	{r4, r5, lr}
 216              	.LCFI1:
 217              		.cfi_def_cfa_offset 12
 218              		.cfi_offset 4, -12
 219              		.cfi_offset 5, -8
 220              		.cfi_offset 14, -4
 221 0002 85B0     		sub	sp, sp, #20
 222              	.LCFI2:
 223              		.cfi_def_cfa_offset 32
 224 0004 0446     		mov	r4, r0
 225 0006 0D46     		mov	r5, r1
 226              	.LVL35:
 248:FWLIB/src/stm32f4xx_usart.c ****   uint32_t tmpreg = 0x00, apbclock = 0x00;
 249:FWLIB/src/stm32f4xx_usart.c ****   uint32_t integerdivider = 0x00;
 250:FWLIB/src/stm32f4xx_usart.c ****   uint32_t fractionaldivider = 0x00;
 251:FWLIB/src/stm32f4xx_usart.c ****   RCC_ClocksTypeDef RCC_ClocksStatus;
 252:FWLIB/src/stm32f4xx_usart.c **** 
 253:FWLIB/src/stm32f4xx_usart.c ****   /* Check the parameters */
 254:FWLIB/src/stm32f4xx_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 255:FWLIB/src/stm32f4xx_usart.c ****   assert_param(IS_USART_BAUDRATE(USART_InitStruct->USART_BaudRate));  
 256:FWLIB/src/stm32f4xx_usart.c ****   assert_param(IS_USART_WORD_LENGTH(USART_InitStruct->USART_WordLength));
 257:FWLIB/src/stm32f4xx_usart.c ****   assert_param(IS_USART_STOPBITS(USART_InitStruct->USART_StopBits));
 258:FWLIB/src/stm32f4xx_usart.c ****   assert_param(IS_USART_PARITY(USART_InitStruct->USART_Parity));
 259:FWLIB/src/stm32f4xx_usart.c ****   assert_param(IS_USART_MODE(USART_InitStruct->USART_Mode));
 260:FWLIB/src/stm32f4xx_usart.c ****   assert_param(IS_USART_HARDWARE_FLOW_CONTROL(USART_InitStruct->USART_HardwareFlowControl));
 261:FWLIB/src/stm32f4xx_usart.c **** 
 262:FWLIB/src/stm32f4xx_usart.c ****   /* The hardware flow control is available only for USART1, USART2, USART3 and USART6 */
 263:FWLIB/src/stm32f4xx_usart.c ****   if (USART_InitStruct->USART_HardwareFlowControl != USART_HardwareFlowControl_None)
 264:FWLIB/src/stm32f4xx_usart.c ****   {
 265:FWLIB/src/stm32f4xx_usart.c ****     assert_param(IS_USART_1236_PERIPH(USARTx));
 266:FWLIB/src/stm32f4xx_usart.c ****   }
 267:FWLIB/src/stm32f4xx_usart.c **** 
 268:FWLIB/src/stm32f4xx_usart.c **** /*---------------------------- USART CR2 Configuration -----------------------*/
 269:FWLIB/src/stm32f4xx_usart.c ****   tmpreg = USARTx->CR2;
 227              		.loc 1 269 0
 228 0008 038A     		ldrh	r3, [r0, #16]
 229 000a 9BB2     		uxth	r3, r3
 230              	.LVL36:
 270:FWLIB/src/stm32f4xx_usart.c **** 
 271:FWLIB/src/stm32f4xx_usart.c ****   /* Clear STOP[13:12] bits */
 272:FWLIB/src/stm32f4xx_usart.c ****   tmpreg &= (uint32_t)~((uint32_t)USART_CR2_STOP);
ARM GAS  /tmp/cc0JzPHi.s 			page 10


 231              		.loc 1 272 0
 232 000c 23F44053 		bic	r3, r3, #12288
 233              	.LVL37:
 273:FWLIB/src/stm32f4xx_usart.c **** 
 274:FWLIB/src/stm32f4xx_usart.c ****   /* Configure the USART Stop Bits, Clock, CPOL, CPHA and LastBit :
 275:FWLIB/src/stm32f4xx_usart.c ****       Set STOP[13:12] bits according to USART_StopBits value */
 276:FWLIB/src/stm32f4xx_usart.c ****   tmpreg |= (uint32_t)USART_InitStruct->USART_StopBits;
 234              		.loc 1 276 0
 235 0010 CA88     		ldrh	r2, [r1, #6]
 236              	.LVL38:
 277:FWLIB/src/stm32f4xx_usart.c ****   
 278:FWLIB/src/stm32f4xx_usart.c ****   /* Write to USART CR2 */
 279:FWLIB/src/stm32f4xx_usart.c ****   USARTx->CR2 = (uint16_t)tmpreg;
 237              		.loc 1 279 0
 238 0012 1343     		orrs	r3, r3, r2
 239              	.LVL39:
 240 0014 0382     		strh	r3, [r0, #16]	@ movhi
 280:FWLIB/src/stm32f4xx_usart.c **** 
 281:FWLIB/src/stm32f4xx_usart.c **** /*---------------------------- USART CR1 Configuration -----------------------*/
 282:FWLIB/src/stm32f4xx_usart.c ****   tmpreg = USARTx->CR1;
 241              		.loc 1 282 0
 242 0016 8389     		ldrh	r3, [r0, #12]
 243              	.LVL40:
 244 0018 9BB2     		uxth	r3, r3
 245              	.LVL41:
 283:FWLIB/src/stm32f4xx_usart.c **** 
 284:FWLIB/src/stm32f4xx_usart.c ****   /* Clear M, PCE, PS, TE and RE bits */
 285:FWLIB/src/stm32f4xx_usart.c ****   tmpreg &= (uint32_t)~((uint32_t)CR1_CLEAR_MASK);
 246              		.loc 1 285 0
 247 001a 23F4B053 		bic	r3, r3, #5632
 248              	.LVL42:
 249 001e 23F00C03 		bic	r3, r3, #12
 250              	.LVL43:
 286:FWLIB/src/stm32f4xx_usart.c **** 
 287:FWLIB/src/stm32f4xx_usart.c ****   /* Configure the USART Word Length, Parity and mode: 
 288:FWLIB/src/stm32f4xx_usart.c ****      Set the M bits according to USART_WordLength value 
 289:FWLIB/src/stm32f4xx_usart.c ****      Set PCE and PS bits according to USART_Parity value
 290:FWLIB/src/stm32f4xx_usart.c ****      Set TE and RE bits according to USART_Mode value */
 291:FWLIB/src/stm32f4xx_usart.c ****   tmpreg |= (uint32_t)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
 251              		.loc 1 291 0
 252 0022 8988     		ldrh	r1, [r1, #4]
 253              	.LVL44:
 254 0024 2889     		ldrh	r0, [r5, #8]
 255              	.LVL45:
 292:FWLIB/src/stm32f4xx_usart.c ****             USART_InitStruct->USART_Mode;
 256              		.loc 1 292 0
 257 0026 6A89     		ldrh	r2, [r5, #10]
 291:FWLIB/src/stm32f4xx_usart.c ****             USART_InitStruct->USART_Mode;
 258              		.loc 1 291 0
 259 0028 0143     		orrs	r1, r1, r0
 260 002a 0A43     		orrs	r2, r2, r1
 261              	.LVL46:
 293:FWLIB/src/stm32f4xx_usart.c **** 
 294:FWLIB/src/stm32f4xx_usart.c ****   /* Write to USART CR1 */
 295:FWLIB/src/stm32f4xx_usart.c ****   USARTx->CR1 = (uint16_t)tmpreg;
 262              		.loc 1 295 0
 263 002c 1343     		orrs	r3, r3, r2
ARM GAS  /tmp/cc0JzPHi.s 			page 11


 264              	.LVL47:
 265 002e A381     		strh	r3, [r4, #12]	@ movhi
 296:FWLIB/src/stm32f4xx_usart.c **** 
 297:FWLIB/src/stm32f4xx_usart.c **** /*---------------------------- USART CR3 Configuration -----------------------*/  
 298:FWLIB/src/stm32f4xx_usart.c ****   tmpreg = USARTx->CR3;
 266              		.loc 1 298 0
 267 0030 A38A     		ldrh	r3, [r4, #20]
 268              	.LVL48:
 269 0032 9BB2     		uxth	r3, r3
 270              	.LVL49:
 299:FWLIB/src/stm32f4xx_usart.c **** 
 300:FWLIB/src/stm32f4xx_usart.c ****   /* Clear CTSE and RTSE bits */
 301:FWLIB/src/stm32f4xx_usart.c ****   tmpreg &= (uint32_t)~((uint32_t)CR3_CLEAR_MASK);
 271              		.loc 1 301 0
 272 0034 23F44073 		bic	r3, r3, #768
 273              	.LVL50:
 302:FWLIB/src/stm32f4xx_usart.c **** 
 303:FWLIB/src/stm32f4xx_usart.c ****   /* Configure the USART HFC : 
 304:FWLIB/src/stm32f4xx_usart.c ****       Set CTSE and RTSE bits according to USART_HardwareFlowControl value */
 305:FWLIB/src/stm32f4xx_usart.c ****   tmpreg |= USART_InitStruct->USART_HardwareFlowControl;
 274              		.loc 1 305 0
 275 0038 AA89     		ldrh	r2, [r5, #12]
 276              	.LVL51:
 306:FWLIB/src/stm32f4xx_usart.c **** 
 307:FWLIB/src/stm32f4xx_usart.c ****   /* Write to USART CR3 */
 308:FWLIB/src/stm32f4xx_usart.c ****   USARTx->CR3 = (uint16_t)tmpreg;
 277              		.loc 1 308 0
 278 003a 1343     		orrs	r3, r3, r2
 279              	.LVL52:
 280 003c A382     		strh	r3, [r4, #20]	@ movhi
 309:FWLIB/src/stm32f4xx_usart.c **** 
 310:FWLIB/src/stm32f4xx_usart.c **** /*---------------------------- USART BRR Configuration -----------------------*/
 311:FWLIB/src/stm32f4xx_usart.c ****   /* Configure the USART Baud Rate */
 312:FWLIB/src/stm32f4xx_usart.c ****   RCC_GetClocksFreq(&RCC_ClocksStatus);
 281              		.loc 1 312 0
 282 003e 6846     		mov	r0, sp
 283 0040 FFF7FEFF 		bl	RCC_GetClocksFreq
 284              	.LVL53:
 313:FWLIB/src/stm32f4xx_usart.c **** 
 314:FWLIB/src/stm32f4xx_usart.c ****   if ((USARTx == USART1) || (USARTx == USART6))
 285              		.loc 1 314 0
 286 0044 204B     		ldr	r3, .L32
 287 0046 9C42     		cmp	r4, r3
 288 0048 28D0     		beq	.L22
 289              		.loc 1 314 0 is_stmt 0 discriminator 1
 290 004a 03F58063 		add	r3, r3, #1024
 291 004e 9C42     		cmp	r4, r3
 292 0050 24D0     		beq	.L22
 315:FWLIB/src/stm32f4xx_usart.c ****   {
 316:FWLIB/src/stm32f4xx_usart.c ****     apbclock = RCC_ClocksStatus.PCLK2_Frequency;
 317:FWLIB/src/stm32f4xx_usart.c ****   }
 318:FWLIB/src/stm32f4xx_usart.c ****   else
 319:FWLIB/src/stm32f4xx_usart.c ****   {
 320:FWLIB/src/stm32f4xx_usart.c ****     apbclock = RCC_ClocksStatus.PCLK1_Frequency;
 293              		.loc 1 320 0 is_stmt 1
 294 0052 029B     		ldr	r3, [sp, #8]
 295              	.LVL54:
ARM GAS  /tmp/cc0JzPHi.s 			page 12


 296              	.L24:
 321:FWLIB/src/stm32f4xx_usart.c ****   }
 322:FWLIB/src/stm32f4xx_usart.c ****   
 323:FWLIB/src/stm32f4xx_usart.c ****   /* Determine the integer part */
 324:FWLIB/src/stm32f4xx_usart.c ****   if ((USARTx->CR1 & USART_CR1_OVER8) != 0)
 297              		.loc 1 324 0
 298 0054 A289     		ldrh	r2, [r4, #12]
 299 0056 12F4004F 		tst	r2, #32768
 300 005a 21D1     		bne	.L30
 325:FWLIB/src/stm32f4xx_usart.c ****   {
 326:FWLIB/src/stm32f4xx_usart.c ****     /* Integer part computing in case Oversampling mode is 8 Samples */
 327:FWLIB/src/stm32f4xx_usart.c ****     integerdivider = ((25 * apbclock) / (2 * (USART_InitStruct->USART_BaudRate)));    
 328:FWLIB/src/stm32f4xx_usart.c ****   }
 329:FWLIB/src/stm32f4xx_usart.c ****   else /* if ((USARTx->CR1 & USART_CR1_OVER8) == 0) */
 330:FWLIB/src/stm32f4xx_usart.c ****   {
 331:FWLIB/src/stm32f4xx_usart.c ****     /* Integer part computing in case Oversampling mode is 16 Samples */
 332:FWLIB/src/stm32f4xx_usart.c ****     integerdivider = ((25 * apbclock) / (4 * (USART_InitStruct->USART_BaudRate)));    
 301              		.loc 1 332 0
 302 005c 03EB8303 		add	r3, r3, r3, lsl #2
 303              	.LVL55:
 304 0060 03EB8303 		add	r3, r3, r3, lsl #2
 305 0064 2968     		ldr	r1, [r5]
 306 0066 8900     		lsls	r1, r1, #2
 307 0068 B3FBF1F1 		udiv	r1, r3, r1
 308              	.LVL56:
 309              	.L26:
 333:FWLIB/src/stm32f4xx_usart.c ****   }
 334:FWLIB/src/stm32f4xx_usart.c ****   tmpreg = (integerdivider / 100) << 4;
 310              		.loc 1 334 0
 311 006c 174B     		ldr	r3, .L32+4
 312 006e A3FB0123 		umull	r2, r3, r3, r1
 313 0072 5809     		lsrs	r0, r3, #5
 314 0074 0501     		lsls	r5, r0, #4
 315              	.LVL57:
 335:FWLIB/src/stm32f4xx_usart.c **** 
 336:FWLIB/src/stm32f4xx_usart.c ****   /* Determine the fractional part */
 337:FWLIB/src/stm32f4xx_usart.c ****   fractionaldivider = integerdivider - (100 * (tmpreg >> 4));
 316              		.loc 1 337 0
 317 0076 6423     		movs	r3, #100
 318 0078 00FB1313 		mls	r3, r0, r3, r1
 319              	.LVL58:
 338:FWLIB/src/stm32f4xx_usart.c **** 
 339:FWLIB/src/stm32f4xx_usart.c ****   /* Implement the fractional part in the register */
 340:FWLIB/src/stm32f4xx_usart.c ****   if ((USARTx->CR1 & USART_CR1_OVER8) != 0)
 320              		.loc 1 340 0
 321 007c A289     		ldrh	r2, [r4, #12]
 322 007e 12F4004F 		tst	r2, #32768
 323 0082 16D1     		bne	.L31
 341:FWLIB/src/stm32f4xx_usart.c ****   {
 342:FWLIB/src/stm32f4xx_usart.c ****     tmpreg |= ((((fractionaldivider * 8) + 50) / 100)) & ((uint8_t)0x07);
 343:FWLIB/src/stm32f4xx_usart.c ****   }
 344:FWLIB/src/stm32f4xx_usart.c ****   else /* if ((USARTx->CR1 & USART_CR1_OVER8) == 0) */
 345:FWLIB/src/stm32f4xx_usart.c ****   {
 346:FWLIB/src/stm32f4xx_usart.c ****     tmpreg |= ((((fractionaldivider * 16) + 50) / 100)) & ((uint8_t)0x0F);
 324              		.loc 1 346 0
 325 0084 1B01     		lsls	r3, r3, #4
 326              	.LVL59:
ARM GAS  /tmp/cc0JzPHi.s 			page 13


 327 0086 3233     		adds	r3, r3, #50
 328 0088 104A     		ldr	r2, .L32+4
 329 008a A2FB0323 		umull	r2, r3, r2, r3
 330 008e C3F34313 		ubfx	r3, r3, #5, #4
 331 0092 2B43     		orrs	r3, r3, r5
 332              	.LVL60:
 333              	.L28:
 347:FWLIB/src/stm32f4xx_usart.c ****   }
 348:FWLIB/src/stm32f4xx_usart.c ****   
 349:FWLIB/src/stm32f4xx_usart.c ****   /* Write to USART BRR register */
 350:FWLIB/src/stm32f4xx_usart.c ****   USARTx->BRR = (uint16_t)tmpreg;
 334              		.loc 1 350 0
 335 0094 9BB2     		uxth	r3, r3
 336              	.LVL61:
 337 0096 2381     		strh	r3, [r4, #8]	@ movhi
 351:FWLIB/src/stm32f4xx_usart.c **** }
 338              		.loc 1 351 0
 339 0098 05B0     		add	sp, sp, #20
 340              	.LCFI3:
 341              		.cfi_remember_state
 342              		.cfi_def_cfa_offset 12
 343              		@ sp needed
 344 009a 30BD     		pop	{r4, r5, pc}
 345              	.LVL62:
 346              	.L22:
 347              	.LCFI4:
 348              		.cfi_restore_state
 316:FWLIB/src/stm32f4xx_usart.c ****   }
 349              		.loc 1 316 0
 350 009c 039B     		ldr	r3, [sp, #12]
 351              	.LVL63:
 352 009e D9E7     		b	.L24
 353              	.L30:
 327:FWLIB/src/stm32f4xx_usart.c ****   }
 354              		.loc 1 327 0
 355 00a0 03EB8303 		add	r3, r3, r3, lsl #2
 356              	.LVL64:
 357 00a4 03EB8303 		add	r3, r3, r3, lsl #2
 358 00a8 2968     		ldr	r1, [r5]
 359 00aa 4900     		lsls	r1, r1, #1
 360 00ac B3FBF1F1 		udiv	r1, r3, r1
 361              	.LVL65:
 362 00b0 DCE7     		b	.L26
 363              	.LVL66:
 364              	.L31:
 342:FWLIB/src/stm32f4xx_usart.c ****   }
 365              		.loc 1 342 0
 366 00b2 D900     		lsls	r1, r3, #3
 367              	.LVL67:
 368 00b4 3231     		adds	r1, r1, #50
 369 00b6 054A     		ldr	r2, .L32+4
 370 00b8 A2FB0131 		umull	r3, r1, r2, r1
 371              	.LVL68:
 372 00bc C1F34212 		ubfx	r2, r1, #5, #3
 373 00c0 45EA0203 		orr	r3, r5, r2
 374              	.LVL69:
 375 00c4 E6E7     		b	.L28
ARM GAS  /tmp/cc0JzPHi.s 			page 14


 376              	.L33:
 377 00c6 00BF     		.align	2
 378              	.L32:
 379 00c8 00100140 		.word	1073811456
 380 00cc 1F85EB51 		.word	1374389535
 381              		.cfi_endproc
 382              	.LFE124:
 384              		.section	.text.USART_StructInit,"ax",%progbits
 385              		.align	1
 386              		.global	USART_StructInit
 387              		.syntax unified
 388              		.thumb
 389              		.thumb_func
 390              		.fpu fpv4-sp-d16
 392              	USART_StructInit:
 393              	.LFB125:
 352:FWLIB/src/stm32f4xx_usart.c **** 
 353:FWLIB/src/stm32f4xx_usart.c **** /**
 354:FWLIB/src/stm32f4xx_usart.c ****   * @brief  Fills each USART_InitStruct member with its default value.
 355:FWLIB/src/stm32f4xx_usart.c ****   * @param  USART_InitStruct: pointer to a USART_InitTypeDef structure which will
 356:FWLIB/src/stm32f4xx_usart.c ****   *         be initialized.
 357:FWLIB/src/stm32f4xx_usart.c ****   * @retval None
 358:FWLIB/src/stm32f4xx_usart.c ****   */
 359:FWLIB/src/stm32f4xx_usart.c **** void USART_StructInit(USART_InitTypeDef* USART_InitStruct)
 360:FWLIB/src/stm32f4xx_usart.c **** {
 394              		.loc 1 360 0
 395              		.cfi_startproc
 396              		@ args = 0, pretend = 0, frame = 0
 397              		@ frame_needed = 0, uses_anonymous_args = 0
 398              		@ link register save eliminated.
 399              	.LVL70:
 361:FWLIB/src/stm32f4xx_usart.c ****   /* USART_InitStruct members default value */
 362:FWLIB/src/stm32f4xx_usart.c ****   USART_InitStruct->USART_BaudRate = 9600;
 400              		.loc 1 362 0
 401 0000 4FF41653 		mov	r3, #9600
 402 0004 0360     		str	r3, [r0]
 363:FWLIB/src/stm32f4xx_usart.c ****   USART_InitStruct->USART_WordLength = USART_WordLength_8b;
 403              		.loc 1 363 0
 404 0006 0023     		movs	r3, #0
 405 0008 8380     		strh	r3, [r0, #4]	@ movhi
 364:FWLIB/src/stm32f4xx_usart.c ****   USART_InitStruct->USART_StopBits = USART_StopBits_1;
 406              		.loc 1 364 0
 407 000a C380     		strh	r3, [r0, #6]	@ movhi
 365:FWLIB/src/stm32f4xx_usart.c ****   USART_InitStruct->USART_Parity = USART_Parity_No ;
 408              		.loc 1 365 0
 409 000c 0381     		strh	r3, [r0, #8]	@ movhi
 366:FWLIB/src/stm32f4xx_usart.c ****   USART_InitStruct->USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
 410              		.loc 1 366 0
 411 000e 0C22     		movs	r2, #12
 412 0010 4281     		strh	r2, [r0, #10]	@ movhi
 367:FWLIB/src/stm32f4xx_usart.c ****   USART_InitStruct->USART_HardwareFlowControl = USART_HardwareFlowControl_None;  
 413              		.loc 1 367 0
 414 0012 8381     		strh	r3, [r0, #12]	@ movhi
 415 0014 7047     		bx	lr
 416              		.cfi_endproc
 417              	.LFE125:
 419              		.section	.text.USART_ClockInit,"ax",%progbits
ARM GAS  /tmp/cc0JzPHi.s 			page 15


 420              		.align	1
 421              		.global	USART_ClockInit
 422              		.syntax unified
 423              		.thumb
 424              		.thumb_func
 425              		.fpu fpv4-sp-d16
 427              	USART_ClockInit:
 428              	.LFB126:
 368:FWLIB/src/stm32f4xx_usart.c **** }
 369:FWLIB/src/stm32f4xx_usart.c **** 
 370:FWLIB/src/stm32f4xx_usart.c **** /**
 371:FWLIB/src/stm32f4xx_usart.c ****   * @brief  Initializes the USARTx peripheral Clock according to the 
 372:FWLIB/src/stm32f4xx_usart.c ****   *         specified parameters in the USART_ClockInitStruct .
 373:FWLIB/src/stm32f4xx_usart.c ****   * @param  USARTx: where x can be 1, 2, 3 or 6 to select the USART peripheral.
 374:FWLIB/src/stm32f4xx_usart.c ****   * @param  USART_ClockInitStruct: pointer to a USART_ClockInitTypeDef structure that
 375:FWLIB/src/stm32f4xx_usart.c ****   *         contains the configuration information for the specified  USART peripheral.
 376:FWLIB/src/stm32f4xx_usart.c ****   * @note   The Smart Card and Synchronous modes are not available for UART4 and UART5.    
 377:FWLIB/src/stm32f4xx_usart.c ****   * @retval None
 378:FWLIB/src/stm32f4xx_usart.c ****   */
 379:FWLIB/src/stm32f4xx_usart.c **** void USART_ClockInit(USART_TypeDef* USARTx, USART_ClockInitTypeDef* USART_ClockInitStruct)
 380:FWLIB/src/stm32f4xx_usart.c **** {
 429              		.loc 1 380 0
 430              		.cfi_startproc
 431              		@ args = 0, pretend = 0, frame = 0
 432              		@ frame_needed = 0, uses_anonymous_args = 0
 433              		@ link register save eliminated.
 434              	.LVL71:
 435 0000 70B4     		push	{r4, r5, r6}
 436              	.LCFI5:
 437              		.cfi_def_cfa_offset 12
 438              		.cfi_offset 4, -12
 439              		.cfi_offset 5, -8
 440              		.cfi_offset 6, -4
 441              	.LVL72:
 381:FWLIB/src/stm32f4xx_usart.c ****   uint32_t tmpreg = 0x00;
 382:FWLIB/src/stm32f4xx_usart.c ****   /* Check the parameters */
 383:FWLIB/src/stm32f4xx_usart.c ****   assert_param(IS_USART_1236_PERIPH(USARTx));
 384:FWLIB/src/stm32f4xx_usart.c ****   assert_param(IS_USART_CLOCK(USART_ClockInitStruct->USART_Clock));
 385:FWLIB/src/stm32f4xx_usart.c ****   assert_param(IS_USART_CPOL(USART_ClockInitStruct->USART_CPOL));
 386:FWLIB/src/stm32f4xx_usart.c ****   assert_param(IS_USART_CPHA(USART_ClockInitStruct->USART_CPHA));
 387:FWLIB/src/stm32f4xx_usart.c ****   assert_param(IS_USART_LASTBIT(USART_ClockInitStruct->USART_LastBit));
 388:FWLIB/src/stm32f4xx_usart.c ****   
 389:FWLIB/src/stm32f4xx_usart.c **** /*---------------------------- USART CR2 Configuration -----------------------*/
 390:FWLIB/src/stm32f4xx_usart.c ****   tmpreg = USARTx->CR2;
 442              		.loc 1 390 0
 443 0002 038A     		ldrh	r3, [r0, #16]
 444 0004 9BB2     		uxth	r3, r3
 445              	.LVL73:
 391:FWLIB/src/stm32f4xx_usart.c ****   /* Clear CLKEN, CPOL, CPHA and LBCL bits */
 392:FWLIB/src/stm32f4xx_usart.c ****   tmpreg &= (uint32_t)~((uint32_t)CR2_CLOCK_CLEAR_MASK);
 446              		.loc 1 392 0
 447 0006 23F47063 		bic	r3, r3, #3840
 448              	.LVL74:
 393:FWLIB/src/stm32f4xx_usart.c ****   /* Configure the USART Clock, CPOL, CPHA and LastBit ------------*/
 394:FWLIB/src/stm32f4xx_usart.c ****   /* Set CLKEN bit according to USART_Clock value */
 395:FWLIB/src/stm32f4xx_usart.c ****   /* Set CPOL bit according to USART_CPOL value */
 396:FWLIB/src/stm32f4xx_usart.c ****   /* Set CPHA bit according to USART_CPHA value */
ARM GAS  /tmp/cc0JzPHi.s 			page 16


 397:FWLIB/src/stm32f4xx_usart.c ****   /* Set LBCL bit according to USART_LastBit value */
 398:FWLIB/src/stm32f4xx_usart.c ****   tmpreg |= (uint32_t)USART_ClockInitStruct->USART_Clock | USART_ClockInitStruct->USART_CPOL | 
 449              		.loc 1 398 0
 450 000a 0D88     		ldrh	r5, [r1]
 451 000c 4E88     		ldrh	r6, [r1, #2]
 399:FWLIB/src/stm32f4xx_usart.c ****                  USART_ClockInitStruct->USART_CPHA | USART_ClockInitStruct->USART_LastBit;
 452              		.loc 1 399 0
 453 000e 8C88     		ldrh	r4, [r1, #4]
 454 0010 CA88     		ldrh	r2, [r1, #6]
 455 0012 45EA0601 		orr	r1, r5, r6
 456              	.LVL75:
 457 0016 2143     		orrs	r1, r1, r4
 458 0018 0A43     		orrs	r2, r2, r1
 459              	.LVL76:
 400:FWLIB/src/stm32f4xx_usart.c ****   /* Write to USART CR2 */
 401:FWLIB/src/stm32f4xx_usart.c ****   USARTx->CR2 = (uint16_t)tmpreg;
 460              		.loc 1 401 0
 461 001a 1343     		orrs	r3, r3, r2
 462              	.LVL77:
 463 001c 0382     		strh	r3, [r0, #16]	@ movhi
 402:FWLIB/src/stm32f4xx_usart.c **** }
 464              		.loc 1 402 0
 465 001e 70BC     		pop	{r4, r5, r6}
 466              	.LCFI6:
 467              		.cfi_restore 6
 468              		.cfi_restore 5
 469              		.cfi_restore 4
 470              		.cfi_def_cfa_offset 0
 471 0020 7047     		bx	lr
 472              		.cfi_endproc
 473              	.LFE126:
 475              		.section	.text.USART_ClockStructInit,"ax",%progbits
 476              		.align	1
 477              		.global	USART_ClockStructInit
 478              		.syntax unified
 479              		.thumb
 480              		.thumb_func
 481              		.fpu fpv4-sp-d16
 483              	USART_ClockStructInit:
 484              	.LFB127:
 403:FWLIB/src/stm32f4xx_usart.c **** 
 404:FWLIB/src/stm32f4xx_usart.c **** /**
 405:FWLIB/src/stm32f4xx_usart.c ****   * @brief  Fills each USART_ClockInitStruct member with its default value.
 406:FWLIB/src/stm32f4xx_usart.c ****   * @param  USART_ClockInitStruct: pointer to a USART_ClockInitTypeDef structure
 407:FWLIB/src/stm32f4xx_usart.c ****   *         which will be initialized.
 408:FWLIB/src/stm32f4xx_usart.c ****   * @retval None
 409:FWLIB/src/stm32f4xx_usart.c ****   */
 410:FWLIB/src/stm32f4xx_usart.c **** void USART_ClockStructInit(USART_ClockInitTypeDef* USART_ClockInitStruct)
 411:FWLIB/src/stm32f4xx_usart.c **** {
 485              		.loc 1 411 0
 486              		.cfi_startproc
 487              		@ args = 0, pretend = 0, frame = 0
 488              		@ frame_needed = 0, uses_anonymous_args = 0
 489              		@ link register save eliminated.
 490              	.LVL78:
 412:FWLIB/src/stm32f4xx_usart.c ****   /* USART_ClockInitStruct members default value */
 413:FWLIB/src/stm32f4xx_usart.c ****   USART_ClockInitStruct->USART_Clock = USART_Clock_Disable;
ARM GAS  /tmp/cc0JzPHi.s 			page 17


 491              		.loc 1 413 0
 492 0000 0023     		movs	r3, #0
 493 0002 0380     		strh	r3, [r0]	@ movhi
 414:FWLIB/src/stm32f4xx_usart.c ****   USART_ClockInitStruct->USART_CPOL = USART_CPOL_Low;
 494              		.loc 1 414 0
 495 0004 4380     		strh	r3, [r0, #2]	@ movhi
 415:FWLIB/src/stm32f4xx_usart.c ****   USART_ClockInitStruct->USART_CPHA = USART_CPHA_1Edge;
 496              		.loc 1 415 0
 497 0006 8380     		strh	r3, [r0, #4]	@ movhi
 416:FWLIB/src/stm32f4xx_usart.c ****   USART_ClockInitStruct->USART_LastBit = USART_LastBit_Disable;
 498              		.loc 1 416 0
 499 0008 C380     		strh	r3, [r0, #6]	@ movhi
 500 000a 7047     		bx	lr
 501              		.cfi_endproc
 502              	.LFE127:
 504              		.section	.text.USART_Cmd,"ax",%progbits
 505              		.align	1
 506              		.global	USART_Cmd
 507              		.syntax unified
 508              		.thumb
 509              		.thumb_func
 510              		.fpu fpv4-sp-d16
 512              	USART_Cmd:
 513              	.LFB128:
 417:FWLIB/src/stm32f4xx_usart.c **** }
 418:FWLIB/src/stm32f4xx_usart.c **** 
 419:FWLIB/src/stm32f4xx_usart.c **** /**
 420:FWLIB/src/stm32f4xx_usart.c ****   * @brief  Enables or disables the specified USART peripheral.
 421:FWLIB/src/stm32f4xx_usart.c ****   * @param  USARTx: where x can be 1, 2, 3, 4, 5, 6, 7 or 8 to select the USART or 
 422:FWLIB/src/stm32f4xx_usart.c ****   *         UART peripheral.
 423:FWLIB/src/stm32f4xx_usart.c ****   * @param  NewState: new state of the USARTx peripheral.
 424:FWLIB/src/stm32f4xx_usart.c ****   *          This parameter can be: ENABLE or DISABLE.
 425:FWLIB/src/stm32f4xx_usart.c ****   * @retval None
 426:FWLIB/src/stm32f4xx_usart.c ****   */
 427:FWLIB/src/stm32f4xx_usart.c **** void USART_Cmd(USART_TypeDef* USARTx, FunctionalState NewState)
 428:FWLIB/src/stm32f4xx_usart.c **** {
 514              		.loc 1 428 0
 515              		.cfi_startproc
 516              		@ args = 0, pretend = 0, frame = 0
 517              		@ frame_needed = 0, uses_anonymous_args = 0
 518              		@ link register save eliminated.
 519              	.LVL79:
 429:FWLIB/src/stm32f4xx_usart.c ****   /* Check the parameters */
 430:FWLIB/src/stm32f4xx_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 431:FWLIB/src/stm32f4xx_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 432:FWLIB/src/stm32f4xx_usart.c ****   
 433:FWLIB/src/stm32f4xx_usart.c ****   if (NewState != DISABLE)
 520              		.loc 1 433 0
 521 0000 31B9     		cbnz	r1, .L41
 434:FWLIB/src/stm32f4xx_usart.c ****   {
 435:FWLIB/src/stm32f4xx_usart.c ****     /* Enable the selected USART by setting the UE bit in the CR1 register */
 436:FWLIB/src/stm32f4xx_usart.c ****     USARTx->CR1 |= USART_CR1_UE;
 437:FWLIB/src/stm32f4xx_usart.c ****   }
 438:FWLIB/src/stm32f4xx_usart.c ****   else
 439:FWLIB/src/stm32f4xx_usart.c ****   {
 440:FWLIB/src/stm32f4xx_usart.c ****     /* Disable the selected USART by clearing the UE bit in the CR1 register */
 441:FWLIB/src/stm32f4xx_usart.c ****     USARTx->CR1 &= (uint16_t)~((uint16_t)USART_CR1_UE);
ARM GAS  /tmp/cc0JzPHi.s 			page 18


 522              		.loc 1 441 0
 523 0002 8389     		ldrh	r3, [r0, #12]
 524 0004 9BB2     		uxth	r3, r3
 525 0006 23F40053 		bic	r3, r3, #8192
 526 000a 9BB2     		uxth	r3, r3
 527 000c 8381     		strh	r3, [r0, #12]	@ movhi
 528 000e 7047     		bx	lr
 529              	.L41:
 436:FWLIB/src/stm32f4xx_usart.c ****   }
 530              		.loc 1 436 0
 531 0010 8389     		ldrh	r3, [r0, #12]
 532 0012 9BB2     		uxth	r3, r3
 533 0014 43F40053 		orr	r3, r3, #8192
 534 0018 8381     		strh	r3, [r0, #12]	@ movhi
 535 001a 7047     		bx	lr
 536              		.cfi_endproc
 537              	.LFE128:
 539              		.section	.text.USART_SetPrescaler,"ax",%progbits
 540              		.align	1
 541              		.global	USART_SetPrescaler
 542              		.syntax unified
 543              		.thumb
 544              		.thumb_func
 545              		.fpu fpv4-sp-d16
 547              	USART_SetPrescaler:
 548              	.LFB129:
 442:FWLIB/src/stm32f4xx_usart.c ****   }
 443:FWLIB/src/stm32f4xx_usart.c **** }
 444:FWLIB/src/stm32f4xx_usart.c **** 
 445:FWLIB/src/stm32f4xx_usart.c **** /**
 446:FWLIB/src/stm32f4xx_usart.c ****   * @brief  Sets the system clock prescaler.
 447:FWLIB/src/stm32f4xx_usart.c ****   * @param  USARTx: where x can be 1, 2, 3, 4, 5, 6, 7 or 8 to select the USART or 
 448:FWLIB/src/stm32f4xx_usart.c ****   *         UART peripheral.
 449:FWLIB/src/stm32f4xx_usart.c ****   * @param  USART_Prescaler: specifies the prescaler clock. 
 450:FWLIB/src/stm32f4xx_usart.c ****   * @note   The function is used for IrDA mode with UART4 and UART5.   
 451:FWLIB/src/stm32f4xx_usart.c ****   * @retval None
 452:FWLIB/src/stm32f4xx_usart.c ****   */
 453:FWLIB/src/stm32f4xx_usart.c **** void USART_SetPrescaler(USART_TypeDef* USARTx, uint8_t USART_Prescaler)
 454:FWLIB/src/stm32f4xx_usart.c **** { 
 549              		.loc 1 454 0
 550              		.cfi_startproc
 551              		@ args = 0, pretend = 0, frame = 0
 552              		@ frame_needed = 0, uses_anonymous_args = 0
 553              		@ link register save eliminated.
 554              	.LVL80:
 455:FWLIB/src/stm32f4xx_usart.c ****   /* Check the parameters */
 456:FWLIB/src/stm32f4xx_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 457:FWLIB/src/stm32f4xx_usart.c ****   
 458:FWLIB/src/stm32f4xx_usart.c ****   /* Clear the USART prescaler */
 459:FWLIB/src/stm32f4xx_usart.c ****   USARTx->GTPR &= USART_GTPR_GT;
 555              		.loc 1 459 0
 556 0000 038B     		ldrh	r3, [r0, #24]
 557 0002 03F47F43 		and	r3, r3, #65280
 558 0006 0383     		strh	r3, [r0, #24]	@ movhi
 460:FWLIB/src/stm32f4xx_usart.c ****   /* Set the USART prescaler */
 461:FWLIB/src/stm32f4xx_usart.c ****   USARTx->GTPR |= USART_Prescaler;
 559              		.loc 1 461 0
ARM GAS  /tmp/cc0JzPHi.s 			page 19


 560 0008 038B     		ldrh	r3, [r0, #24]
 561 000a 9BB2     		uxth	r3, r3
 562 000c 1943     		orrs	r1, r1, r3
 563              	.LVL81:
 564 000e 0183     		strh	r1, [r0, #24]	@ movhi
 565 0010 7047     		bx	lr
 566              		.cfi_endproc
 567              	.LFE129:
 569              		.section	.text.USART_OverSampling8Cmd,"ax",%progbits
 570              		.align	1
 571              		.global	USART_OverSampling8Cmd
 572              		.syntax unified
 573              		.thumb
 574              		.thumb_func
 575              		.fpu fpv4-sp-d16
 577              	USART_OverSampling8Cmd:
 578              	.LFB130:
 462:FWLIB/src/stm32f4xx_usart.c **** }
 463:FWLIB/src/stm32f4xx_usart.c **** 
 464:FWLIB/src/stm32f4xx_usart.c **** /**
 465:FWLIB/src/stm32f4xx_usart.c ****   * @brief  Enables or disables the USART's 8x oversampling mode.
 466:FWLIB/src/stm32f4xx_usart.c ****   * @note   This function has to be called before calling USART_Init() function
 467:FWLIB/src/stm32f4xx_usart.c ****   *         in order to have correct baudrate Divider value.
 468:FWLIB/src/stm32f4xx_usart.c ****   * @param  USARTx: where x can be 1, 2, 3, 4, 5, 6, 7 or 8 to select the USART or 
 469:FWLIB/src/stm32f4xx_usart.c ****   *         UART peripheral.
 470:FWLIB/src/stm32f4xx_usart.c ****   * @param  NewState: new state of the USART 8x oversampling mode.
 471:FWLIB/src/stm32f4xx_usart.c ****   *          This parameter can be: ENABLE or DISABLE.
 472:FWLIB/src/stm32f4xx_usart.c ****   * @retval None
 473:FWLIB/src/stm32f4xx_usart.c ****   */
 474:FWLIB/src/stm32f4xx_usart.c **** void USART_OverSampling8Cmd(USART_TypeDef* USARTx, FunctionalState NewState)
 475:FWLIB/src/stm32f4xx_usart.c **** {
 579              		.loc 1 475 0
 580              		.cfi_startproc
 581              		@ args = 0, pretend = 0, frame = 0
 582              		@ frame_needed = 0, uses_anonymous_args = 0
 583              		@ link register save eliminated.
 584              	.LVL82:
 476:FWLIB/src/stm32f4xx_usart.c ****   /* Check the parameters */
 477:FWLIB/src/stm32f4xx_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 478:FWLIB/src/stm32f4xx_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 479:FWLIB/src/stm32f4xx_usart.c ****   
 480:FWLIB/src/stm32f4xx_usart.c ****   if (NewState != DISABLE)
 585              		.loc 1 480 0
 586 0000 21B9     		cbnz	r1, .L46
 481:FWLIB/src/stm32f4xx_usart.c ****   {
 482:FWLIB/src/stm32f4xx_usart.c ****     /* Enable the 8x Oversampling mode by setting the OVER8 bit in the CR1 register */
 483:FWLIB/src/stm32f4xx_usart.c ****     USARTx->CR1 |= USART_CR1_OVER8;
 484:FWLIB/src/stm32f4xx_usart.c ****   }
 485:FWLIB/src/stm32f4xx_usart.c ****   else
 486:FWLIB/src/stm32f4xx_usart.c ****   {
 487:FWLIB/src/stm32f4xx_usart.c ****     /* Disable the 8x Oversampling mode by clearing the OVER8 bit in the CR1 register */
 488:FWLIB/src/stm32f4xx_usart.c ****     USARTx->CR1 &= (uint16_t)~((uint16_t)USART_CR1_OVER8);
 587              		.loc 1 488 0
 588 0002 8389     		ldrh	r3, [r0, #12]
 589 0004 C3F30E03 		ubfx	r3, r3, #0, #15
 590 0008 8381     		strh	r3, [r0, #12]	@ movhi
 591 000a 7047     		bx	lr
ARM GAS  /tmp/cc0JzPHi.s 			page 20


 592              	.L46:
 483:FWLIB/src/stm32f4xx_usart.c ****   }
 593              		.loc 1 483 0
 594 000c 8389     		ldrh	r3, [r0, #12]
 595 000e 6FEA4343 		mvn	r3, r3, lsl #17
 596 0012 6FEA5343 		mvn	r3, r3, lsr #17
 597 0016 9BB2     		uxth	r3, r3
 598 0018 8381     		strh	r3, [r0, #12]	@ movhi
 599 001a 7047     		bx	lr
 600              		.cfi_endproc
 601              	.LFE130:
 603              		.section	.text.USART_OneBitMethodCmd,"ax",%progbits
 604              		.align	1
 605              		.global	USART_OneBitMethodCmd
 606              		.syntax unified
 607              		.thumb
 608              		.thumb_func
 609              		.fpu fpv4-sp-d16
 611              	USART_OneBitMethodCmd:
 612              	.LFB131:
 489:FWLIB/src/stm32f4xx_usart.c ****   }
 490:FWLIB/src/stm32f4xx_usart.c **** }  
 491:FWLIB/src/stm32f4xx_usart.c **** 
 492:FWLIB/src/stm32f4xx_usart.c **** /**
 493:FWLIB/src/stm32f4xx_usart.c ****   * @brief  Enables or disables the USART's one bit sampling method.
 494:FWLIB/src/stm32f4xx_usart.c ****   * @param  USARTx: where x can be 1, 2, 3, 4, 5, 6, 7 or 8 to select the USART or 
 495:FWLIB/src/stm32f4xx_usart.c ****   *         UART peripheral.
 496:FWLIB/src/stm32f4xx_usart.c ****   * @param  NewState: new state of the USART one bit sampling method.
 497:FWLIB/src/stm32f4xx_usart.c ****   *          This parameter can be: ENABLE or DISABLE.
 498:FWLIB/src/stm32f4xx_usart.c ****   * @retval None
 499:FWLIB/src/stm32f4xx_usart.c ****   */
 500:FWLIB/src/stm32f4xx_usart.c **** void USART_OneBitMethodCmd(USART_TypeDef* USARTx, FunctionalState NewState)
 501:FWLIB/src/stm32f4xx_usart.c **** {
 613              		.loc 1 501 0
 614              		.cfi_startproc
 615              		@ args = 0, pretend = 0, frame = 0
 616              		@ frame_needed = 0, uses_anonymous_args = 0
 617              		@ link register save eliminated.
 618              	.LVL83:
 502:FWLIB/src/stm32f4xx_usart.c ****   /* Check the parameters */
 503:FWLIB/src/stm32f4xx_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 504:FWLIB/src/stm32f4xx_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 505:FWLIB/src/stm32f4xx_usart.c ****   
 506:FWLIB/src/stm32f4xx_usart.c ****   if (NewState != DISABLE)
 619              		.loc 1 506 0
 620 0000 31B9     		cbnz	r1, .L50
 507:FWLIB/src/stm32f4xx_usart.c ****   {
 508:FWLIB/src/stm32f4xx_usart.c ****     /* Enable the one bit method by setting the ONEBITE bit in the CR3 register */
 509:FWLIB/src/stm32f4xx_usart.c ****     USARTx->CR3 |= USART_CR3_ONEBIT;
 510:FWLIB/src/stm32f4xx_usart.c ****   }
 511:FWLIB/src/stm32f4xx_usart.c ****   else
 512:FWLIB/src/stm32f4xx_usart.c ****   {
 513:FWLIB/src/stm32f4xx_usart.c ****     /* Disable the one bit method by clearing the ONEBITE bit in the CR3 register */
 514:FWLIB/src/stm32f4xx_usart.c ****     USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_ONEBIT);
 621              		.loc 1 514 0
 622 0002 838A     		ldrh	r3, [r0, #20]
 623 0004 9BB2     		uxth	r3, r3
ARM GAS  /tmp/cc0JzPHi.s 			page 21


 624 0006 23F40063 		bic	r3, r3, #2048
 625 000a 9BB2     		uxth	r3, r3
 626 000c 8382     		strh	r3, [r0, #20]	@ movhi
 627 000e 7047     		bx	lr
 628              	.L50:
 509:FWLIB/src/stm32f4xx_usart.c ****   }
 629              		.loc 1 509 0
 630 0010 838A     		ldrh	r3, [r0, #20]
 631 0012 9BB2     		uxth	r3, r3
 632 0014 43F40063 		orr	r3, r3, #2048
 633 0018 8382     		strh	r3, [r0, #20]	@ movhi
 634 001a 7047     		bx	lr
 635              		.cfi_endproc
 636              	.LFE131:
 638              		.section	.text.USART_SendData,"ax",%progbits
 639              		.align	1
 640              		.global	USART_SendData
 641              		.syntax unified
 642              		.thumb
 643              		.thumb_func
 644              		.fpu fpv4-sp-d16
 646              	USART_SendData:
 647              	.LFB132:
 515:FWLIB/src/stm32f4xx_usart.c ****   }
 516:FWLIB/src/stm32f4xx_usart.c **** }
 517:FWLIB/src/stm32f4xx_usart.c **** 
 518:FWLIB/src/stm32f4xx_usart.c **** /**
 519:FWLIB/src/stm32f4xx_usart.c ****   * @}
 520:FWLIB/src/stm32f4xx_usart.c ****   */
 521:FWLIB/src/stm32f4xx_usart.c **** 
 522:FWLIB/src/stm32f4xx_usart.c **** /** @defgroup USART_Group2 Data transfers functions
 523:FWLIB/src/stm32f4xx_usart.c ****  *  @brief   Data transfers functions 
 524:FWLIB/src/stm32f4xx_usart.c ****  *
 525:FWLIB/src/stm32f4xx_usart.c **** @verbatim   
 526:FWLIB/src/stm32f4xx_usart.c ****  ===============================================================================
 527:FWLIB/src/stm32f4xx_usart.c ****                       ##### Data transfers functions #####
 528:FWLIB/src/stm32f4xx_usart.c ****  ===============================================================================  
 529:FWLIB/src/stm32f4xx_usart.c ****     [..]
 530:FWLIB/src/stm32f4xx_usart.c ****     This subsection provides a set of functions allowing to manage the USART data 
 531:FWLIB/src/stm32f4xx_usart.c ****     transfers.
 532:FWLIB/src/stm32f4xx_usart.c ****     [..]
 533:FWLIB/src/stm32f4xx_usart.c ****     During an USART reception, data shifts in least significant bit first through 
 534:FWLIB/src/stm32f4xx_usart.c ****     the RX pin. In this mode, the USART_DR register consists of a buffer (RDR) 
 535:FWLIB/src/stm32f4xx_usart.c ****     between the internal bus and the received shift register.
 536:FWLIB/src/stm32f4xx_usart.c ****     [..]
 537:FWLIB/src/stm32f4xx_usart.c ****     When a transmission is taking place, a write instruction to the USART_DR register 
 538:FWLIB/src/stm32f4xx_usart.c ****     stores the data in the TDR register and which is copied in the shift register 
 539:FWLIB/src/stm32f4xx_usart.c ****     at the end of the current transmission.
 540:FWLIB/src/stm32f4xx_usart.c ****     [..]
 541:FWLIB/src/stm32f4xx_usart.c ****     The read access of the USART_DR register can be done using the USART_ReceiveData()
 542:FWLIB/src/stm32f4xx_usart.c ****     function and returns the RDR buffered value. Whereas a write access to the USART_DR 
 543:FWLIB/src/stm32f4xx_usart.c ****     can be done using USART_SendData() function and stores the written data into 
 544:FWLIB/src/stm32f4xx_usart.c ****     TDR buffer.
 545:FWLIB/src/stm32f4xx_usart.c **** 
 546:FWLIB/src/stm32f4xx_usart.c **** @endverbatim
 547:FWLIB/src/stm32f4xx_usart.c ****   * @{
 548:FWLIB/src/stm32f4xx_usart.c ****   */
ARM GAS  /tmp/cc0JzPHi.s 			page 22


 549:FWLIB/src/stm32f4xx_usart.c **** 
 550:FWLIB/src/stm32f4xx_usart.c **** /**
 551:FWLIB/src/stm32f4xx_usart.c ****   * @brief  Transmits single data through the USARTx peripheral.
 552:FWLIB/src/stm32f4xx_usart.c ****   * @param  USARTx: where x can be 1, 2, 3, 4, 5, 6, 7 or 8 to select the USART or 
 553:FWLIB/src/stm32f4xx_usart.c ****   *         UART peripheral.
 554:FWLIB/src/stm32f4xx_usart.c ****   * @param  Data: the data to transmit.
 555:FWLIB/src/stm32f4xx_usart.c ****   * @retval None
 556:FWLIB/src/stm32f4xx_usart.c ****   */
 557:FWLIB/src/stm32f4xx_usart.c **** void USART_SendData(USART_TypeDef* USARTx, uint16_t Data)
 558:FWLIB/src/stm32f4xx_usart.c **** {
 648              		.loc 1 558 0
 649              		.cfi_startproc
 650              		@ args = 0, pretend = 0, frame = 0
 651              		@ frame_needed = 0, uses_anonymous_args = 0
 652              		@ link register save eliminated.
 653              	.LVL84:
 559:FWLIB/src/stm32f4xx_usart.c ****   /* Check the parameters */
 560:FWLIB/src/stm32f4xx_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 561:FWLIB/src/stm32f4xx_usart.c ****   assert_param(IS_USART_DATA(Data)); 
 562:FWLIB/src/stm32f4xx_usart.c ****     
 563:FWLIB/src/stm32f4xx_usart.c ****   /* Transmit Data */
 564:FWLIB/src/stm32f4xx_usart.c ****   USARTx->DR = (Data & (uint16_t)0x01FF);
 654              		.loc 1 564 0
 655 0000 C1F30801 		ubfx	r1, r1, #0, #9
 656              	.LVL85:
 657 0004 8180     		strh	r1, [r0, #4]	@ movhi
 658 0006 7047     		bx	lr
 659              		.cfi_endproc
 660              	.LFE132:
 662              		.section	.text.USART_ReceiveData,"ax",%progbits
 663              		.align	1
 664              		.global	USART_ReceiveData
 665              		.syntax unified
 666              		.thumb
 667              		.thumb_func
 668              		.fpu fpv4-sp-d16
 670              	USART_ReceiveData:
 671              	.LFB133:
 565:FWLIB/src/stm32f4xx_usart.c **** }
 566:FWLIB/src/stm32f4xx_usart.c **** 
 567:FWLIB/src/stm32f4xx_usart.c **** /**
 568:FWLIB/src/stm32f4xx_usart.c ****   * @brief  Returns the most recent received data by the USARTx peripheral.
 569:FWLIB/src/stm32f4xx_usart.c ****   * @param  USARTx: where x can be 1, 2, 3, 4, 5, 6, 7 or 8 to select the USART or 
 570:FWLIB/src/stm32f4xx_usart.c ****   *         UART peripheral.
 571:FWLIB/src/stm32f4xx_usart.c ****   * @retval The received data.
 572:FWLIB/src/stm32f4xx_usart.c ****   */
 573:FWLIB/src/stm32f4xx_usart.c **** uint16_t USART_ReceiveData(USART_TypeDef* USARTx)
 574:FWLIB/src/stm32f4xx_usart.c **** {
 672              		.loc 1 574 0
 673              		.cfi_startproc
 674              		@ args = 0, pretend = 0, frame = 0
 675              		@ frame_needed = 0, uses_anonymous_args = 0
 676              		@ link register save eliminated.
 677              	.LVL86:
 575:FWLIB/src/stm32f4xx_usart.c ****   /* Check the parameters */
 576:FWLIB/src/stm32f4xx_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 577:FWLIB/src/stm32f4xx_usart.c ****   
ARM GAS  /tmp/cc0JzPHi.s 			page 23


 578:FWLIB/src/stm32f4xx_usart.c ****   /* Receive Data */
 579:FWLIB/src/stm32f4xx_usart.c ****   return (uint16_t)(USARTx->DR & (uint16_t)0x01FF);
 678              		.loc 1 579 0
 679 0000 8088     		ldrh	r0, [r0, #4]
 680              	.LVL87:
 580:FWLIB/src/stm32f4xx_usart.c **** }
 681              		.loc 1 580 0
 682 0002 C0F30800 		ubfx	r0, r0, #0, #9
 683 0006 7047     		bx	lr
 684              		.cfi_endproc
 685              	.LFE133:
 687              		.section	.text.USART_SetAddress,"ax",%progbits
 688              		.align	1
 689              		.global	USART_SetAddress
 690              		.syntax unified
 691              		.thumb
 692              		.thumb_func
 693              		.fpu fpv4-sp-d16
 695              	USART_SetAddress:
 696              	.LFB134:
 581:FWLIB/src/stm32f4xx_usart.c **** 
 582:FWLIB/src/stm32f4xx_usart.c **** /**
 583:FWLIB/src/stm32f4xx_usart.c ****   * @}
 584:FWLIB/src/stm32f4xx_usart.c ****   */
 585:FWLIB/src/stm32f4xx_usart.c **** 
 586:FWLIB/src/stm32f4xx_usart.c **** /** @defgroup USART_Group3 MultiProcessor Communication functions
 587:FWLIB/src/stm32f4xx_usart.c ****  *  @brief   Multi-Processor Communication functions 
 588:FWLIB/src/stm32f4xx_usart.c ****  *
 589:FWLIB/src/stm32f4xx_usart.c **** @verbatim   
 590:FWLIB/src/stm32f4xx_usart.c ****  ===============================================================================
 591:FWLIB/src/stm32f4xx_usart.c ****               ##### Multi-Processor Communication functions #####
 592:FWLIB/src/stm32f4xx_usart.c ****  ===============================================================================  
 593:FWLIB/src/stm32f4xx_usart.c ****     [..]
 594:FWLIB/src/stm32f4xx_usart.c ****     This subsection provides a set of functions allowing to manage the USART 
 595:FWLIB/src/stm32f4xx_usart.c ****     multiprocessor communication.
 596:FWLIB/src/stm32f4xx_usart.c ****     [..]
 597:FWLIB/src/stm32f4xx_usart.c ****     For instance one of the USARTs can be the master, its TX output is connected 
 598:FWLIB/src/stm32f4xx_usart.c ****     to the RX input of the other USART. The others are slaves, their respective 
 599:FWLIB/src/stm32f4xx_usart.c ****     TX outputs are logically ANDed together and connected to the RX input of the 
 600:FWLIB/src/stm32f4xx_usart.c ****     master.
 601:FWLIB/src/stm32f4xx_usart.c ****     [..]
 602:FWLIB/src/stm32f4xx_usart.c ****     USART multiprocessor communication is possible through the following procedure:
 603:FWLIB/src/stm32f4xx_usart.c ****       (#) Program the Baud rate, Word length = 9 bits, Stop bits, Parity, Mode 
 604:FWLIB/src/stm32f4xx_usart.c ****           transmitter or Mode receiver and hardware flow control values using 
 605:FWLIB/src/stm32f4xx_usart.c ****           the USART_Init() function.
 606:FWLIB/src/stm32f4xx_usart.c ****       (#) Configures the USART address using the USART_SetAddress() function.
 607:FWLIB/src/stm32f4xx_usart.c ****       (#) Configures the wake up method (USART_WakeUp_IdleLine or USART_WakeUp_AddressMark)
 608:FWLIB/src/stm32f4xx_usart.c ****           using USART_WakeUpConfig() function only for the slaves.
 609:FWLIB/src/stm32f4xx_usart.c ****       (#) Enable the USART using the USART_Cmd() function.
 610:FWLIB/src/stm32f4xx_usart.c ****       (#) Enter the USART slaves in mute mode using USART_ReceiverWakeUpCmd() function.
 611:FWLIB/src/stm32f4xx_usart.c ****     [..]
 612:FWLIB/src/stm32f4xx_usart.c ****     The USART Slave exit from mute mode when receive the wake up condition.
 613:FWLIB/src/stm32f4xx_usart.c **** 
 614:FWLIB/src/stm32f4xx_usart.c **** @endverbatim
 615:FWLIB/src/stm32f4xx_usart.c ****   * @{
 616:FWLIB/src/stm32f4xx_usart.c ****   */
 617:FWLIB/src/stm32f4xx_usart.c **** 
ARM GAS  /tmp/cc0JzPHi.s 			page 24


 618:FWLIB/src/stm32f4xx_usart.c **** /**
 619:FWLIB/src/stm32f4xx_usart.c ****   * @brief  Sets the address of the USART node.
 620:FWLIB/src/stm32f4xx_usart.c ****   * @param  USARTx: where x can be 1, 2, 3, 4, 5, 6, 7 or 8 to select the USART or 
 621:FWLIB/src/stm32f4xx_usart.c ****   *         UART peripheral.
 622:FWLIB/src/stm32f4xx_usart.c ****   * @param  USART_Address: Indicates the address of the USART node.
 623:FWLIB/src/stm32f4xx_usart.c ****   * @retval None
 624:FWLIB/src/stm32f4xx_usart.c ****   */
 625:FWLIB/src/stm32f4xx_usart.c **** void USART_SetAddress(USART_TypeDef* USARTx, uint8_t USART_Address)
 626:FWLIB/src/stm32f4xx_usart.c **** {
 697              		.loc 1 626 0
 698              		.cfi_startproc
 699              		@ args = 0, pretend = 0, frame = 0
 700              		@ frame_needed = 0, uses_anonymous_args = 0
 701              		@ link register save eliminated.
 702              	.LVL88:
 627:FWLIB/src/stm32f4xx_usart.c ****   /* Check the parameters */
 628:FWLIB/src/stm32f4xx_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 629:FWLIB/src/stm32f4xx_usart.c ****   assert_param(IS_USART_ADDRESS(USART_Address)); 
 630:FWLIB/src/stm32f4xx_usart.c ****     
 631:FWLIB/src/stm32f4xx_usart.c ****   /* Clear the USART address */
 632:FWLIB/src/stm32f4xx_usart.c ****   USARTx->CR2 &= (uint16_t)~((uint16_t)USART_CR2_ADD);
 703              		.loc 1 632 0
 704 0000 038A     		ldrh	r3, [r0, #16]
 705 0002 9BB2     		uxth	r3, r3
 706 0004 23F00F03 		bic	r3, r3, #15
 707 0008 9BB2     		uxth	r3, r3
 708 000a 0382     		strh	r3, [r0, #16]	@ movhi
 633:FWLIB/src/stm32f4xx_usart.c ****   /* Set the USART address node */
 634:FWLIB/src/stm32f4xx_usart.c ****   USARTx->CR2 |= USART_Address;
 709              		.loc 1 634 0
 710 000c 038A     		ldrh	r3, [r0, #16]
 711 000e 9BB2     		uxth	r3, r3
 712 0010 1943     		orrs	r1, r1, r3
 713              	.LVL89:
 714 0012 0182     		strh	r1, [r0, #16]	@ movhi
 715 0014 7047     		bx	lr
 716              		.cfi_endproc
 717              	.LFE134:
 719              		.section	.text.USART_ReceiverWakeUpCmd,"ax",%progbits
 720              		.align	1
 721              		.global	USART_ReceiverWakeUpCmd
 722              		.syntax unified
 723              		.thumb
 724              		.thumb_func
 725              		.fpu fpv4-sp-d16
 727              	USART_ReceiverWakeUpCmd:
 728              	.LFB135:
 635:FWLIB/src/stm32f4xx_usart.c **** }
 636:FWLIB/src/stm32f4xx_usart.c **** 
 637:FWLIB/src/stm32f4xx_usart.c **** /**
 638:FWLIB/src/stm32f4xx_usart.c ****   * @brief  Determines if the USART is in mute mode or not.
 639:FWLIB/src/stm32f4xx_usart.c ****   * @param  USARTx: where x can be 1, 2, 3, 4, 5, 6, 7 or 8 to select the USART or 
 640:FWLIB/src/stm32f4xx_usart.c ****   *         UART peripheral.
 641:FWLIB/src/stm32f4xx_usart.c ****   * @param  NewState: new state of the USART mute mode.
 642:FWLIB/src/stm32f4xx_usart.c ****   *          This parameter can be: ENABLE or DISABLE.
 643:FWLIB/src/stm32f4xx_usart.c ****   * @retval None
 644:FWLIB/src/stm32f4xx_usart.c ****   */
ARM GAS  /tmp/cc0JzPHi.s 			page 25


 645:FWLIB/src/stm32f4xx_usart.c **** void USART_ReceiverWakeUpCmd(USART_TypeDef* USARTx, FunctionalState NewState)
 646:FWLIB/src/stm32f4xx_usart.c **** {
 729              		.loc 1 646 0
 730              		.cfi_startproc
 731              		@ args = 0, pretend = 0, frame = 0
 732              		@ frame_needed = 0, uses_anonymous_args = 0
 733              		@ link register save eliminated.
 734              	.LVL90:
 647:FWLIB/src/stm32f4xx_usart.c ****   /* Check the parameters */
 648:FWLIB/src/stm32f4xx_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 649:FWLIB/src/stm32f4xx_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState)); 
 650:FWLIB/src/stm32f4xx_usart.c ****   
 651:FWLIB/src/stm32f4xx_usart.c ****   if (NewState != DISABLE)
 735              		.loc 1 651 0
 736 0000 31B9     		cbnz	r1, .L57
 652:FWLIB/src/stm32f4xx_usart.c ****   {
 653:FWLIB/src/stm32f4xx_usart.c ****     /* Enable the USART mute mode  by setting the RWU bit in the CR1 register */
 654:FWLIB/src/stm32f4xx_usart.c ****     USARTx->CR1 |= USART_CR1_RWU;
 655:FWLIB/src/stm32f4xx_usart.c ****   }
 656:FWLIB/src/stm32f4xx_usart.c ****   else
 657:FWLIB/src/stm32f4xx_usart.c ****   {
 658:FWLIB/src/stm32f4xx_usart.c ****     /* Disable the USART mute mode by clearing the RWU bit in the CR1 register */
 659:FWLIB/src/stm32f4xx_usart.c ****     USARTx->CR1 &= (uint16_t)~((uint16_t)USART_CR1_RWU);
 737              		.loc 1 659 0
 738 0002 8389     		ldrh	r3, [r0, #12]
 739 0004 9BB2     		uxth	r3, r3
 740 0006 23F00203 		bic	r3, r3, #2
 741 000a 9BB2     		uxth	r3, r3
 742 000c 8381     		strh	r3, [r0, #12]	@ movhi
 743 000e 7047     		bx	lr
 744              	.L57:
 654:FWLIB/src/stm32f4xx_usart.c ****   }
 745              		.loc 1 654 0
 746 0010 8389     		ldrh	r3, [r0, #12]
 747 0012 9BB2     		uxth	r3, r3
 748 0014 43F00203 		orr	r3, r3, #2
 749 0018 8381     		strh	r3, [r0, #12]	@ movhi
 750 001a 7047     		bx	lr
 751              		.cfi_endproc
 752              	.LFE135:
 754              		.section	.text.USART_WakeUpConfig,"ax",%progbits
 755              		.align	1
 756              		.global	USART_WakeUpConfig
 757              		.syntax unified
 758              		.thumb
 759              		.thumb_func
 760              		.fpu fpv4-sp-d16
 762              	USART_WakeUpConfig:
 763              	.LFB136:
 660:FWLIB/src/stm32f4xx_usart.c ****   }
 661:FWLIB/src/stm32f4xx_usart.c **** }
 662:FWLIB/src/stm32f4xx_usart.c **** /**
 663:FWLIB/src/stm32f4xx_usart.c ****   * @brief  Selects the USART WakeUp method.
 664:FWLIB/src/stm32f4xx_usart.c ****   * @param  USARTx: where x can be 1, 2, 3, 4, 5, 6, 7 or 8 to select the USART or 
 665:FWLIB/src/stm32f4xx_usart.c ****   *         UART peripheral.
 666:FWLIB/src/stm32f4xx_usart.c ****   * @param  USART_WakeUp: specifies the USART wakeup method.
 667:FWLIB/src/stm32f4xx_usart.c ****   *          This parameter can be one of the following values:
ARM GAS  /tmp/cc0JzPHi.s 			page 26


 668:FWLIB/src/stm32f4xx_usart.c ****   *            @arg USART_WakeUp_IdleLine: WakeUp by an idle line detection
 669:FWLIB/src/stm32f4xx_usart.c ****   *            @arg USART_WakeUp_AddressMark: WakeUp by an address mark
 670:FWLIB/src/stm32f4xx_usart.c ****   * @retval None
 671:FWLIB/src/stm32f4xx_usart.c ****   */
 672:FWLIB/src/stm32f4xx_usart.c **** void USART_WakeUpConfig(USART_TypeDef* USARTx, uint16_t USART_WakeUp)
 673:FWLIB/src/stm32f4xx_usart.c **** {
 764              		.loc 1 673 0
 765              		.cfi_startproc
 766              		@ args = 0, pretend = 0, frame = 0
 767              		@ frame_needed = 0, uses_anonymous_args = 0
 768              		@ link register save eliminated.
 769              	.LVL91:
 674:FWLIB/src/stm32f4xx_usart.c ****   /* Check the parameters */
 675:FWLIB/src/stm32f4xx_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 676:FWLIB/src/stm32f4xx_usart.c ****   assert_param(IS_USART_WAKEUP(USART_WakeUp));
 677:FWLIB/src/stm32f4xx_usart.c ****   
 678:FWLIB/src/stm32f4xx_usart.c ****   USARTx->CR1 &= (uint16_t)~((uint16_t)USART_CR1_WAKE);
 770              		.loc 1 678 0
 771 0000 8389     		ldrh	r3, [r0, #12]
 772 0002 9BB2     		uxth	r3, r3
 773 0004 23F40063 		bic	r3, r3, #2048
 774 0008 9BB2     		uxth	r3, r3
 775 000a 8381     		strh	r3, [r0, #12]	@ movhi
 679:FWLIB/src/stm32f4xx_usart.c ****   USARTx->CR1 |= USART_WakeUp;
 776              		.loc 1 679 0
 777 000c 8389     		ldrh	r3, [r0, #12]
 778 000e 9BB2     		uxth	r3, r3
 779 0010 1943     		orrs	r1, r1, r3
 780              	.LVL92:
 781 0012 8181     		strh	r1, [r0, #12]	@ movhi
 782 0014 7047     		bx	lr
 783              		.cfi_endproc
 784              	.LFE136:
 786              		.section	.text.USART_LINBreakDetectLengthConfig,"ax",%progbits
 787              		.align	1
 788              		.global	USART_LINBreakDetectLengthConfig
 789              		.syntax unified
 790              		.thumb
 791              		.thumb_func
 792              		.fpu fpv4-sp-d16
 794              	USART_LINBreakDetectLengthConfig:
 795              	.LFB137:
 680:FWLIB/src/stm32f4xx_usart.c **** }
 681:FWLIB/src/stm32f4xx_usart.c **** 
 682:FWLIB/src/stm32f4xx_usart.c **** /**
 683:FWLIB/src/stm32f4xx_usart.c ****   * @}
 684:FWLIB/src/stm32f4xx_usart.c ****   */
 685:FWLIB/src/stm32f4xx_usart.c **** 
 686:FWLIB/src/stm32f4xx_usart.c **** /** @defgroup USART_Group4 LIN mode functions
 687:FWLIB/src/stm32f4xx_usart.c ****  *  @brief   LIN mode functions 
 688:FWLIB/src/stm32f4xx_usart.c ****  *
 689:FWLIB/src/stm32f4xx_usart.c **** @verbatim   
 690:FWLIB/src/stm32f4xx_usart.c ****  ===============================================================================
 691:FWLIB/src/stm32f4xx_usart.c ****                         ##### LIN mode functions #####
 692:FWLIB/src/stm32f4xx_usart.c ****  ===============================================================================  
 693:FWLIB/src/stm32f4xx_usart.c ****     [..]
 694:FWLIB/src/stm32f4xx_usart.c ****     This subsection provides a set of functions allowing to manage the USART LIN 
ARM GAS  /tmp/cc0JzPHi.s 			page 27


 695:FWLIB/src/stm32f4xx_usart.c ****     Mode communication.
 696:FWLIB/src/stm32f4xx_usart.c ****     [..]
 697:FWLIB/src/stm32f4xx_usart.c ****     In LIN mode, 8-bit data format with 1 stop bit is required in accordance with 
 698:FWLIB/src/stm32f4xx_usart.c ****     the LIN standard.
 699:FWLIB/src/stm32f4xx_usart.c ****     [..]
 700:FWLIB/src/stm32f4xx_usart.c ****     Only this LIN Feature is supported by the USART IP:
 701:FWLIB/src/stm32f4xx_usart.c ****       (+) LIN Master Synchronous Break send capability and LIN slave break detection
 702:FWLIB/src/stm32f4xx_usart.c ****           capability :  13-bit break generation and 10/11 bit break detection
 703:FWLIB/src/stm32f4xx_usart.c **** 
 704:FWLIB/src/stm32f4xx_usart.c ****     [..]
 705:FWLIB/src/stm32f4xx_usart.c ****     USART LIN Master transmitter communication is possible through the following 
 706:FWLIB/src/stm32f4xx_usart.c ****     procedure:
 707:FWLIB/src/stm32f4xx_usart.c ****       (#) Program the Baud rate, Word length = 8bits, Stop bits = 1bit, Parity, 
 708:FWLIB/src/stm32f4xx_usart.c ****         Mode transmitter or Mode receiver and hardware flow control values using 
 709:FWLIB/src/stm32f4xx_usart.c ****         the USART_Init() function.
 710:FWLIB/src/stm32f4xx_usart.c ****       (#) Enable the USART using the USART_Cmd() function.
 711:FWLIB/src/stm32f4xx_usart.c ****       (#) Enable the LIN mode using the USART_LINCmd() function.
 712:FWLIB/src/stm32f4xx_usart.c ****       (#) Send the break character using USART_SendBreak() function.
 713:FWLIB/src/stm32f4xx_usart.c ****     [..]
 714:FWLIB/src/stm32f4xx_usart.c ****     USART LIN Master receiver communication is possible through the following procedure:
 715:FWLIB/src/stm32f4xx_usart.c ****       (#) Program the Baud rate, Word length = 8bits, Stop bits = 1bit, Parity, 
 716:FWLIB/src/stm32f4xx_usart.c ****           Mode transmitter or Mode receiver and hardware flow control values using 
 717:FWLIB/src/stm32f4xx_usart.c ****           the USART_Init() function.
 718:FWLIB/src/stm32f4xx_usart.c ****       (#) Enable the USART using the USART_Cmd() function.
 719:FWLIB/src/stm32f4xx_usart.c ****       (#) Configures the break detection length using the USART_LINBreakDetectLengthConfig()
 720:FWLIB/src/stm32f4xx_usart.c ****           function.
 721:FWLIB/src/stm32f4xx_usart.c ****       (#) Enable the LIN mode using the USART_LINCmd() function.
 722:FWLIB/src/stm32f4xx_usart.c **** 
 723:FWLIB/src/stm32f4xx_usart.c ****       -@- In LIN mode, the following bits must be kept cleared:
 724:FWLIB/src/stm32f4xx_usart.c ****        (+@) CLKEN in the USART_CR2 register,
 725:FWLIB/src/stm32f4xx_usart.c ****        (+@) STOP[1:0], SCEN, HDSEL and IREN in the USART_CR3 register.
 726:FWLIB/src/stm32f4xx_usart.c **** 
 727:FWLIB/src/stm32f4xx_usart.c **** @endverbatim
 728:FWLIB/src/stm32f4xx_usart.c ****   * @{
 729:FWLIB/src/stm32f4xx_usart.c ****   */
 730:FWLIB/src/stm32f4xx_usart.c **** 
 731:FWLIB/src/stm32f4xx_usart.c **** /**
 732:FWLIB/src/stm32f4xx_usart.c ****   * @brief  Sets the USART LIN Break detection length.
 733:FWLIB/src/stm32f4xx_usart.c ****   * @param  USARTx: where x can be 1, 2, 3, 4, 5, 6, 7 or 8 to select the USART or 
 734:FWLIB/src/stm32f4xx_usart.c ****   *         UART peripheral.
 735:FWLIB/src/stm32f4xx_usart.c ****   * @param  USART_LINBreakDetectLength: specifies the LIN break detection length.
 736:FWLIB/src/stm32f4xx_usart.c ****   *          This parameter can be one of the following values:
 737:FWLIB/src/stm32f4xx_usart.c ****   *            @arg USART_LINBreakDetectLength_10b: 10-bit break detection
 738:FWLIB/src/stm32f4xx_usart.c ****   *            @arg USART_LINBreakDetectLength_11b: 11-bit break detection
 739:FWLIB/src/stm32f4xx_usart.c ****   * @retval None
 740:FWLIB/src/stm32f4xx_usart.c ****   */
 741:FWLIB/src/stm32f4xx_usart.c **** void USART_LINBreakDetectLengthConfig(USART_TypeDef* USARTx, uint16_t USART_LINBreakDetectLength)
 742:FWLIB/src/stm32f4xx_usart.c **** {
 796              		.loc 1 742 0
 797              		.cfi_startproc
 798              		@ args = 0, pretend = 0, frame = 0
 799              		@ frame_needed = 0, uses_anonymous_args = 0
 800              		@ link register save eliminated.
 801              	.LVL93:
 743:FWLIB/src/stm32f4xx_usart.c ****   /* Check the parameters */
 744:FWLIB/src/stm32f4xx_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 745:FWLIB/src/stm32f4xx_usart.c ****   assert_param(IS_USART_LIN_BREAK_DETECT_LENGTH(USART_LINBreakDetectLength));
ARM GAS  /tmp/cc0JzPHi.s 			page 28


 746:FWLIB/src/stm32f4xx_usart.c ****   
 747:FWLIB/src/stm32f4xx_usart.c ****   USARTx->CR2 &= (uint16_t)~((uint16_t)USART_CR2_LBDL);
 802              		.loc 1 747 0
 803 0000 038A     		ldrh	r3, [r0, #16]
 804 0002 9BB2     		uxth	r3, r3
 805 0004 23F02003 		bic	r3, r3, #32
 806 0008 9BB2     		uxth	r3, r3
 807 000a 0382     		strh	r3, [r0, #16]	@ movhi
 748:FWLIB/src/stm32f4xx_usart.c ****   USARTx->CR2 |= USART_LINBreakDetectLength;  
 808              		.loc 1 748 0
 809 000c 038A     		ldrh	r3, [r0, #16]
 810 000e 9BB2     		uxth	r3, r3
 811 0010 1943     		orrs	r1, r1, r3
 812              	.LVL94:
 813 0012 0182     		strh	r1, [r0, #16]	@ movhi
 814 0014 7047     		bx	lr
 815              		.cfi_endproc
 816              	.LFE137:
 818              		.section	.text.USART_LINCmd,"ax",%progbits
 819              		.align	1
 820              		.global	USART_LINCmd
 821              		.syntax unified
 822              		.thumb
 823              		.thumb_func
 824              		.fpu fpv4-sp-d16
 826              	USART_LINCmd:
 827              	.LFB138:
 749:FWLIB/src/stm32f4xx_usart.c **** }
 750:FWLIB/src/stm32f4xx_usart.c **** 
 751:FWLIB/src/stm32f4xx_usart.c **** /**
 752:FWLIB/src/stm32f4xx_usart.c ****   * @brief  Enables or disables the USART's LIN mode.
 753:FWLIB/src/stm32f4xx_usart.c ****   * @param  USARTx: where x can be 1, 2, 3, 4, 5, 6, 7 or 8 to select the USART or 
 754:FWLIB/src/stm32f4xx_usart.c ****   *         UART peripheral.
 755:FWLIB/src/stm32f4xx_usart.c ****   * @param  NewState: new state of the USART LIN mode.
 756:FWLIB/src/stm32f4xx_usart.c ****   *          This parameter can be: ENABLE or DISABLE.
 757:FWLIB/src/stm32f4xx_usart.c ****   * @retval None
 758:FWLIB/src/stm32f4xx_usart.c ****   */
 759:FWLIB/src/stm32f4xx_usart.c **** void USART_LINCmd(USART_TypeDef* USARTx, FunctionalState NewState)
 760:FWLIB/src/stm32f4xx_usart.c **** {
 828              		.loc 1 760 0
 829              		.cfi_startproc
 830              		@ args = 0, pretend = 0, frame = 0
 831              		@ frame_needed = 0, uses_anonymous_args = 0
 832              		@ link register save eliminated.
 833              	.LVL95:
 761:FWLIB/src/stm32f4xx_usart.c ****   /* Check the parameters */
 762:FWLIB/src/stm32f4xx_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 763:FWLIB/src/stm32f4xx_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 764:FWLIB/src/stm32f4xx_usart.c ****   
 765:FWLIB/src/stm32f4xx_usart.c ****   if (NewState != DISABLE)
 834              		.loc 1 765 0
 835 0000 31B9     		cbnz	r1, .L63
 766:FWLIB/src/stm32f4xx_usart.c ****   {
 767:FWLIB/src/stm32f4xx_usart.c ****     /* Enable the LIN mode by setting the LINEN bit in the CR2 register */
 768:FWLIB/src/stm32f4xx_usart.c ****     USARTx->CR2 |= USART_CR2_LINEN;
 769:FWLIB/src/stm32f4xx_usart.c ****   }
 770:FWLIB/src/stm32f4xx_usart.c ****   else
ARM GAS  /tmp/cc0JzPHi.s 			page 29


 771:FWLIB/src/stm32f4xx_usart.c ****   {
 772:FWLIB/src/stm32f4xx_usart.c ****     /* Disable the LIN mode by clearing the LINEN bit in the CR2 register */
 773:FWLIB/src/stm32f4xx_usart.c ****     USARTx->CR2 &= (uint16_t)~((uint16_t)USART_CR2_LINEN);
 836              		.loc 1 773 0
 837 0002 038A     		ldrh	r3, [r0, #16]
 838 0004 9BB2     		uxth	r3, r3
 839 0006 23F48043 		bic	r3, r3, #16384
 840 000a 9BB2     		uxth	r3, r3
 841 000c 0382     		strh	r3, [r0, #16]	@ movhi
 842 000e 7047     		bx	lr
 843              	.L63:
 768:FWLIB/src/stm32f4xx_usart.c ****   }
 844              		.loc 1 768 0
 845 0010 038A     		ldrh	r3, [r0, #16]
 846 0012 9BB2     		uxth	r3, r3
 847 0014 43F48043 		orr	r3, r3, #16384
 848 0018 0382     		strh	r3, [r0, #16]	@ movhi
 849 001a 7047     		bx	lr
 850              		.cfi_endproc
 851              	.LFE138:
 853              		.section	.text.USART_SendBreak,"ax",%progbits
 854              		.align	1
 855              		.global	USART_SendBreak
 856              		.syntax unified
 857              		.thumb
 858              		.thumb_func
 859              		.fpu fpv4-sp-d16
 861              	USART_SendBreak:
 862              	.LFB139:
 774:FWLIB/src/stm32f4xx_usart.c ****   }
 775:FWLIB/src/stm32f4xx_usart.c **** }
 776:FWLIB/src/stm32f4xx_usart.c **** 
 777:FWLIB/src/stm32f4xx_usart.c **** /**
 778:FWLIB/src/stm32f4xx_usart.c ****   * @brief  Transmits break characters.
 779:FWLIB/src/stm32f4xx_usart.c ****   * @param  USARTx: where x can be 1, 2, 3, 4, 5, 6, 7 or 8 to select the USART or 
 780:FWLIB/src/stm32f4xx_usart.c ****   *         UART peripheral.
 781:FWLIB/src/stm32f4xx_usart.c ****   * @retval None
 782:FWLIB/src/stm32f4xx_usart.c ****   */
 783:FWLIB/src/stm32f4xx_usart.c **** void USART_SendBreak(USART_TypeDef* USARTx)
 784:FWLIB/src/stm32f4xx_usart.c **** {
 863              		.loc 1 784 0
 864              		.cfi_startproc
 865              		@ args = 0, pretend = 0, frame = 0
 866              		@ frame_needed = 0, uses_anonymous_args = 0
 867              		@ link register save eliminated.
 868              	.LVL96:
 785:FWLIB/src/stm32f4xx_usart.c ****   /* Check the parameters */
 786:FWLIB/src/stm32f4xx_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 787:FWLIB/src/stm32f4xx_usart.c ****   
 788:FWLIB/src/stm32f4xx_usart.c ****   /* Send break characters */
 789:FWLIB/src/stm32f4xx_usart.c ****   USARTx->CR1 |= USART_CR1_SBK;
 869              		.loc 1 789 0
 870 0000 8389     		ldrh	r3, [r0, #12]
 871 0002 9BB2     		uxth	r3, r3
 872 0004 43F00103 		orr	r3, r3, #1
 873 0008 8381     		strh	r3, [r0, #12]	@ movhi
 874 000a 7047     		bx	lr
ARM GAS  /tmp/cc0JzPHi.s 			page 30


 875              		.cfi_endproc
 876              	.LFE139:
 878              		.section	.text.USART_HalfDuplexCmd,"ax",%progbits
 879              		.align	1
 880              		.global	USART_HalfDuplexCmd
 881              		.syntax unified
 882              		.thumb
 883              		.thumb_func
 884              		.fpu fpv4-sp-d16
 886              	USART_HalfDuplexCmd:
 887              	.LFB140:
 790:FWLIB/src/stm32f4xx_usart.c **** }
 791:FWLIB/src/stm32f4xx_usart.c **** 
 792:FWLIB/src/stm32f4xx_usart.c **** /**
 793:FWLIB/src/stm32f4xx_usart.c ****   * @}
 794:FWLIB/src/stm32f4xx_usart.c ****   */
 795:FWLIB/src/stm32f4xx_usart.c **** 
 796:FWLIB/src/stm32f4xx_usart.c **** /** @defgroup USART_Group5 Halfduplex mode function
 797:FWLIB/src/stm32f4xx_usart.c ****  *  @brief   Half-duplex mode function 
 798:FWLIB/src/stm32f4xx_usart.c ****  *
 799:FWLIB/src/stm32f4xx_usart.c **** @verbatim   
 800:FWLIB/src/stm32f4xx_usart.c ****  ===============================================================================
 801:FWLIB/src/stm32f4xx_usart.c ****                     ##### Half-duplex mode function #####
 802:FWLIB/src/stm32f4xx_usart.c ****  ===============================================================================  
 803:FWLIB/src/stm32f4xx_usart.c ****     [..]
 804:FWLIB/src/stm32f4xx_usart.c ****     This subsection provides a set of functions allowing to manage the USART 
 805:FWLIB/src/stm32f4xx_usart.c ****     Half-duplex communication.
 806:FWLIB/src/stm32f4xx_usart.c ****     [..]
 807:FWLIB/src/stm32f4xx_usart.c ****     The USART can be configured to follow a single-wire half-duplex protocol where 
 808:FWLIB/src/stm32f4xx_usart.c ****     the TX and RX lines are internally connected.
 809:FWLIB/src/stm32f4xx_usart.c ****     [..]
 810:FWLIB/src/stm32f4xx_usart.c ****     USART Half duplex communication is possible through the following procedure:
 811:FWLIB/src/stm32f4xx_usart.c ****       (#) Program the Baud rate, Word length, Stop bits, Parity, Mode transmitter 
 812:FWLIB/src/stm32f4xx_usart.c ****           or Mode receiver and hardware flow control values using the USART_Init()
 813:FWLIB/src/stm32f4xx_usart.c ****           function.
 814:FWLIB/src/stm32f4xx_usart.c ****       (#) Configures the USART address using the USART_SetAddress() function.
 815:FWLIB/src/stm32f4xx_usart.c ****       (#) Enable the USART using the USART_Cmd() function.
 816:FWLIB/src/stm32f4xx_usart.c ****       (#) Enable the half duplex mode using USART_HalfDuplexCmd() function.
 817:FWLIB/src/stm32f4xx_usart.c **** 
 818:FWLIB/src/stm32f4xx_usart.c **** 
 819:FWLIB/src/stm32f4xx_usart.c ****     -@- The RX pin is no longer used
 820:FWLIB/src/stm32f4xx_usart.c ****     -@- In Half-duplex mode the following bits must be kept cleared:
 821:FWLIB/src/stm32f4xx_usart.c ****       (+@) LINEN and CLKEN bits in the USART_CR2 register.
 822:FWLIB/src/stm32f4xx_usart.c ****       (+@) SCEN and IREN bits in the USART_CR3 register.
 823:FWLIB/src/stm32f4xx_usart.c **** 
 824:FWLIB/src/stm32f4xx_usart.c **** @endverbatim
 825:FWLIB/src/stm32f4xx_usart.c ****   * @{
 826:FWLIB/src/stm32f4xx_usart.c ****   */
 827:FWLIB/src/stm32f4xx_usart.c **** 
 828:FWLIB/src/stm32f4xx_usart.c **** /**
 829:FWLIB/src/stm32f4xx_usart.c ****   * @brief  Enables or disables the USART's Half Duplex communication.
 830:FWLIB/src/stm32f4xx_usart.c ****   * @param  USARTx: where x can be 1, 2, 3, 4, 5, 6, 7 or 8 to select the USART or 
 831:FWLIB/src/stm32f4xx_usart.c ****   *         UART peripheral.
 832:FWLIB/src/stm32f4xx_usart.c ****   * @param  NewState: new state of the USART Communication.
 833:FWLIB/src/stm32f4xx_usart.c ****   *          This parameter can be: ENABLE or DISABLE.
 834:FWLIB/src/stm32f4xx_usart.c ****   * @retval None
 835:FWLIB/src/stm32f4xx_usart.c ****   */
ARM GAS  /tmp/cc0JzPHi.s 			page 31


 836:FWLIB/src/stm32f4xx_usart.c **** void USART_HalfDuplexCmd(USART_TypeDef* USARTx, FunctionalState NewState)
 837:FWLIB/src/stm32f4xx_usart.c **** {
 888              		.loc 1 837 0
 889              		.cfi_startproc
 890              		@ args = 0, pretend = 0, frame = 0
 891              		@ frame_needed = 0, uses_anonymous_args = 0
 892              		@ link register save eliminated.
 893              	.LVL97:
 838:FWLIB/src/stm32f4xx_usart.c ****   /* Check the parameters */
 839:FWLIB/src/stm32f4xx_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 840:FWLIB/src/stm32f4xx_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 841:FWLIB/src/stm32f4xx_usart.c ****   
 842:FWLIB/src/stm32f4xx_usart.c ****   if (NewState != DISABLE)
 894              		.loc 1 842 0
 895 0000 31B9     		cbnz	r1, .L68
 843:FWLIB/src/stm32f4xx_usart.c ****   {
 844:FWLIB/src/stm32f4xx_usart.c ****     /* Enable the Half-Duplex mode by setting the HDSEL bit in the CR3 register */
 845:FWLIB/src/stm32f4xx_usart.c ****     USARTx->CR3 |= USART_CR3_HDSEL;
 846:FWLIB/src/stm32f4xx_usart.c ****   }
 847:FWLIB/src/stm32f4xx_usart.c ****   else
 848:FWLIB/src/stm32f4xx_usart.c ****   {
 849:FWLIB/src/stm32f4xx_usart.c ****     /* Disable the Half-Duplex mode by clearing the HDSEL bit in the CR3 register */
 850:FWLIB/src/stm32f4xx_usart.c ****     USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_HDSEL);
 896              		.loc 1 850 0
 897 0002 838A     		ldrh	r3, [r0, #20]
 898 0004 9BB2     		uxth	r3, r3
 899 0006 23F00803 		bic	r3, r3, #8
 900 000a 9BB2     		uxth	r3, r3
 901 000c 8382     		strh	r3, [r0, #20]	@ movhi
 902 000e 7047     		bx	lr
 903              	.L68:
 845:FWLIB/src/stm32f4xx_usart.c ****   }
 904              		.loc 1 845 0
 905 0010 838A     		ldrh	r3, [r0, #20]
 906 0012 9BB2     		uxth	r3, r3
 907 0014 43F00803 		orr	r3, r3, #8
 908 0018 8382     		strh	r3, [r0, #20]	@ movhi
 909 001a 7047     		bx	lr
 910              		.cfi_endproc
 911              	.LFE140:
 913              		.section	.text.USART_SetGuardTime,"ax",%progbits
 914              		.align	1
 915              		.global	USART_SetGuardTime
 916              		.syntax unified
 917              		.thumb
 918              		.thumb_func
 919              		.fpu fpv4-sp-d16
 921              	USART_SetGuardTime:
 922              	.LFB141:
 851:FWLIB/src/stm32f4xx_usart.c ****   }
 852:FWLIB/src/stm32f4xx_usart.c **** }
 853:FWLIB/src/stm32f4xx_usart.c **** 
 854:FWLIB/src/stm32f4xx_usart.c **** /**
 855:FWLIB/src/stm32f4xx_usart.c ****   * @}
 856:FWLIB/src/stm32f4xx_usart.c ****   */
 857:FWLIB/src/stm32f4xx_usart.c **** 
 858:FWLIB/src/stm32f4xx_usart.c **** 
ARM GAS  /tmp/cc0JzPHi.s 			page 32


 859:FWLIB/src/stm32f4xx_usart.c **** /** @defgroup USART_Group6 Smartcard mode functions
 860:FWLIB/src/stm32f4xx_usart.c ****  *  @brief   Smartcard mode functions 
 861:FWLIB/src/stm32f4xx_usart.c ****  *
 862:FWLIB/src/stm32f4xx_usart.c **** @verbatim   
 863:FWLIB/src/stm32f4xx_usart.c ****  ===============================================================================
 864:FWLIB/src/stm32f4xx_usart.c ****                               ##### Smartcard mode functions #####
 865:FWLIB/src/stm32f4xx_usart.c ****  ===============================================================================  
 866:FWLIB/src/stm32f4xx_usart.c ****     [..]
 867:FWLIB/src/stm32f4xx_usart.c ****     This subsection provides a set of functions allowing to manage the USART 
 868:FWLIB/src/stm32f4xx_usart.c ****     Smartcard communication.
 869:FWLIB/src/stm32f4xx_usart.c ****     [..]
 870:FWLIB/src/stm32f4xx_usart.c ****     The Smartcard interface is designed to support asynchronous protocol Smartcards as
 871:FWLIB/src/stm32f4xx_usart.c ****     defined in the ISO 7816-3 standard.
 872:FWLIB/src/stm32f4xx_usart.c ****     [..]
 873:FWLIB/src/stm32f4xx_usart.c ****     The USART can provide a clock to the smartcard through the SCLK output.
 874:FWLIB/src/stm32f4xx_usart.c ****     In smartcard mode, SCLK is not associated to the communication but is simply derived 
 875:FWLIB/src/stm32f4xx_usart.c ****     from the internal peripheral input clock through a 5-bit prescaler.
 876:FWLIB/src/stm32f4xx_usart.c ****     [..]
 877:FWLIB/src/stm32f4xx_usart.c ****     Smartcard communication is possible through the following procedure:
 878:FWLIB/src/stm32f4xx_usart.c ****       (#) Configures the Smartcard Prescaler using the USART_SetPrescaler() function.
 879:FWLIB/src/stm32f4xx_usart.c ****       (#) Configures the Smartcard Guard Time using the USART_SetGuardTime() function.
 880:FWLIB/src/stm32f4xx_usart.c ****       (#) Program the USART clock using the USART_ClockInit() function as following:
 881:FWLIB/src/stm32f4xx_usart.c ****         (++) USART Clock enabled
 882:FWLIB/src/stm32f4xx_usart.c ****         (++) USART CPOL Low
 883:FWLIB/src/stm32f4xx_usart.c ****         (++) USART CPHA on first edge
 884:FWLIB/src/stm32f4xx_usart.c ****         (++) USART Last Bit Clock Enabled
 885:FWLIB/src/stm32f4xx_usart.c ****       (#) Program the Smartcard interface using the USART_Init() function as following:
 886:FWLIB/src/stm32f4xx_usart.c ****         (++) Word Length = 9 Bits
 887:FWLIB/src/stm32f4xx_usart.c ****         (++) 1.5 Stop Bit
 888:FWLIB/src/stm32f4xx_usart.c ****         (++) Even parity
 889:FWLIB/src/stm32f4xx_usart.c ****         (++) BaudRate = 12096 baud
 890:FWLIB/src/stm32f4xx_usart.c ****         (++) Hardware flow control disabled (RTS and CTS signals)
 891:FWLIB/src/stm32f4xx_usart.c ****         (++) Tx and Rx enabled
 892:FWLIB/src/stm32f4xx_usart.c ****       (#) POptionally you can enable the parity error interrupt using the USART_ITConfig()
 893:FWLIB/src/stm32f4xx_usart.c ****           function
 894:FWLIB/src/stm32f4xx_usart.c ****       (#) PEnable the USART using the USART_Cmd() function.
 895:FWLIB/src/stm32f4xx_usart.c ****       (#) PEnable the Smartcard NACK using the USART_SmartCardNACKCmd() function.
 896:FWLIB/src/stm32f4xx_usart.c ****       (#) PEnable the Smartcard interface using the USART_SmartCardCmd() function.
 897:FWLIB/src/stm32f4xx_usart.c **** 
 898:FWLIB/src/stm32f4xx_usart.c ****     Please refer to the ISO 7816-3 specification for more details.
 899:FWLIB/src/stm32f4xx_usart.c **** 
 900:FWLIB/src/stm32f4xx_usart.c ****       -@- It is also possible to choose 0.5 stop bit for receiving but it is recommended 
 901:FWLIB/src/stm32f4xx_usart.c ****           to use 1.5 stop bits for both transmitting and receiving to avoid switching 
 902:FWLIB/src/stm32f4xx_usart.c ****           between the two configurations.
 903:FWLIB/src/stm32f4xx_usart.c ****       -@- In smartcard mode, the following bits must be kept cleared:
 904:FWLIB/src/stm32f4xx_usart.c ****         (+@) LINEN bit in the USART_CR2 register.
 905:FWLIB/src/stm32f4xx_usart.c ****         (+@) HDSEL and IREN bits in the USART_CR3 register.
 906:FWLIB/src/stm32f4xx_usart.c ****       -@- Smartcard mode is available on USART peripherals only (not available on UART4 
 907:FWLIB/src/stm32f4xx_usart.c ****           and UART5 peripherals).
 908:FWLIB/src/stm32f4xx_usart.c **** 
 909:FWLIB/src/stm32f4xx_usart.c **** @endverbatim
 910:FWLIB/src/stm32f4xx_usart.c ****   * @{
 911:FWLIB/src/stm32f4xx_usart.c ****   */
 912:FWLIB/src/stm32f4xx_usart.c **** 
 913:FWLIB/src/stm32f4xx_usart.c **** /**
 914:FWLIB/src/stm32f4xx_usart.c ****   * @brief  Sets the specified USART guard time.
 915:FWLIB/src/stm32f4xx_usart.c ****   * @param  USARTx: where x can be 1, 2, 3 or 6 to select the USART or 
ARM GAS  /tmp/cc0JzPHi.s 			page 33


 916:FWLIB/src/stm32f4xx_usart.c ****   *         UART peripheral.
 917:FWLIB/src/stm32f4xx_usart.c ****   * @param  USART_GuardTime: specifies the guard time.   
 918:FWLIB/src/stm32f4xx_usart.c ****   * @retval None
 919:FWLIB/src/stm32f4xx_usart.c ****   */
 920:FWLIB/src/stm32f4xx_usart.c **** void USART_SetGuardTime(USART_TypeDef* USARTx, uint8_t USART_GuardTime)
 921:FWLIB/src/stm32f4xx_usart.c **** {    
 923              		.loc 1 921 0
 924              		.cfi_startproc
 925              		@ args = 0, pretend = 0, frame = 0
 926              		@ frame_needed = 0, uses_anonymous_args = 0
 927              		@ link register save eliminated.
 928              	.LVL98:
 922:FWLIB/src/stm32f4xx_usart.c ****   /* Check the parameters */
 923:FWLIB/src/stm32f4xx_usart.c ****   assert_param(IS_USART_1236_PERIPH(USARTx));
 924:FWLIB/src/stm32f4xx_usart.c ****   
 925:FWLIB/src/stm32f4xx_usart.c ****   /* Clear the USART Guard time */
 926:FWLIB/src/stm32f4xx_usart.c ****   USARTx->GTPR &= USART_GTPR_PSC;
 929              		.loc 1 926 0
 930 0000 038B     		ldrh	r3, [r0, #24]
 931 0002 DBB2     		uxtb	r3, r3
 932 0004 0383     		strh	r3, [r0, #24]	@ movhi
 927:FWLIB/src/stm32f4xx_usart.c ****   /* Set the USART guard time */
 928:FWLIB/src/stm32f4xx_usart.c ****   USARTx->GTPR |= (uint16_t)((uint16_t)USART_GuardTime << 0x08);
 933              		.loc 1 928 0
 934 0006 038B     		ldrh	r3, [r0, #24]
 935 0008 9BB2     		uxth	r3, r3
 936 000a 43EA0121 		orr	r1, r3, r1, lsl #8
 937              	.LVL99:
 938 000e 0183     		strh	r1, [r0, #24]	@ movhi
 939 0010 7047     		bx	lr
 940              		.cfi_endproc
 941              	.LFE141:
 943              		.section	.text.USART_SmartCardCmd,"ax",%progbits
 944              		.align	1
 945              		.global	USART_SmartCardCmd
 946              		.syntax unified
 947              		.thumb
 948              		.thumb_func
 949              		.fpu fpv4-sp-d16
 951              	USART_SmartCardCmd:
 952              	.LFB142:
 929:FWLIB/src/stm32f4xx_usart.c **** }
 930:FWLIB/src/stm32f4xx_usart.c **** 
 931:FWLIB/src/stm32f4xx_usart.c **** /**
 932:FWLIB/src/stm32f4xx_usart.c ****   * @brief  Enables or disables the USART's Smart Card mode.
 933:FWLIB/src/stm32f4xx_usart.c ****   * @param  USARTx: where x can be 1, 2, 3 or 6 to select the USART or 
 934:FWLIB/src/stm32f4xx_usart.c ****   *         UART peripheral.
 935:FWLIB/src/stm32f4xx_usart.c ****   * @param  NewState: new state of the Smart Card mode.
 936:FWLIB/src/stm32f4xx_usart.c ****   *          This parameter can be: ENABLE or DISABLE.      
 937:FWLIB/src/stm32f4xx_usart.c ****   * @retval None
 938:FWLIB/src/stm32f4xx_usart.c ****   */
 939:FWLIB/src/stm32f4xx_usart.c **** void USART_SmartCardCmd(USART_TypeDef* USARTx, FunctionalState NewState)
 940:FWLIB/src/stm32f4xx_usart.c **** {
 953              		.loc 1 940 0
 954              		.cfi_startproc
 955              		@ args = 0, pretend = 0, frame = 0
 956              		@ frame_needed = 0, uses_anonymous_args = 0
ARM GAS  /tmp/cc0JzPHi.s 			page 34


 957              		@ link register save eliminated.
 958              	.LVL100:
 941:FWLIB/src/stm32f4xx_usart.c ****   /* Check the parameters */
 942:FWLIB/src/stm32f4xx_usart.c ****   assert_param(IS_USART_1236_PERIPH(USARTx));
 943:FWLIB/src/stm32f4xx_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 944:FWLIB/src/stm32f4xx_usart.c ****   if (NewState != DISABLE)
 959              		.loc 1 944 0
 960 0000 31B9     		cbnz	r1, .L73
 945:FWLIB/src/stm32f4xx_usart.c ****   {
 946:FWLIB/src/stm32f4xx_usart.c ****     /* Enable the SC mode by setting the SCEN bit in the CR3 register */
 947:FWLIB/src/stm32f4xx_usart.c ****     USARTx->CR3 |= USART_CR3_SCEN;
 948:FWLIB/src/stm32f4xx_usart.c ****   }
 949:FWLIB/src/stm32f4xx_usart.c ****   else
 950:FWLIB/src/stm32f4xx_usart.c ****   {
 951:FWLIB/src/stm32f4xx_usart.c ****     /* Disable the SC mode by clearing the SCEN bit in the CR3 register */
 952:FWLIB/src/stm32f4xx_usart.c ****     USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_SCEN);
 961              		.loc 1 952 0
 962 0002 838A     		ldrh	r3, [r0, #20]
 963 0004 9BB2     		uxth	r3, r3
 964 0006 23F02003 		bic	r3, r3, #32
 965 000a 9BB2     		uxth	r3, r3
 966 000c 8382     		strh	r3, [r0, #20]	@ movhi
 967 000e 7047     		bx	lr
 968              	.L73:
 947:FWLIB/src/stm32f4xx_usart.c ****   }
 969              		.loc 1 947 0
 970 0010 838A     		ldrh	r3, [r0, #20]
 971 0012 9BB2     		uxth	r3, r3
 972 0014 43F02003 		orr	r3, r3, #32
 973 0018 8382     		strh	r3, [r0, #20]	@ movhi
 974 001a 7047     		bx	lr
 975              		.cfi_endproc
 976              	.LFE142:
 978              		.section	.text.USART_SmartCardNACKCmd,"ax",%progbits
 979              		.align	1
 980              		.global	USART_SmartCardNACKCmd
 981              		.syntax unified
 982              		.thumb
 983              		.thumb_func
 984              		.fpu fpv4-sp-d16
 986              	USART_SmartCardNACKCmd:
 987              	.LFB143:
 953:FWLIB/src/stm32f4xx_usart.c ****   }
 954:FWLIB/src/stm32f4xx_usart.c **** }
 955:FWLIB/src/stm32f4xx_usart.c **** 
 956:FWLIB/src/stm32f4xx_usart.c **** /**
 957:FWLIB/src/stm32f4xx_usart.c ****   * @brief  Enables or disables NACK transmission.
 958:FWLIB/src/stm32f4xx_usart.c ****   * @param  USARTx: where x can be 1, 2, 3 or 6 to select the USART or 
 959:FWLIB/src/stm32f4xx_usart.c ****   *         UART peripheral.
 960:FWLIB/src/stm32f4xx_usart.c ****   * @param  NewState: new state of the NACK transmission.
 961:FWLIB/src/stm32f4xx_usart.c ****   *          This parameter can be: ENABLE or DISABLE.  
 962:FWLIB/src/stm32f4xx_usart.c ****   * @retval None
 963:FWLIB/src/stm32f4xx_usart.c ****   */
 964:FWLIB/src/stm32f4xx_usart.c **** void USART_SmartCardNACKCmd(USART_TypeDef* USARTx, FunctionalState NewState)
 965:FWLIB/src/stm32f4xx_usart.c **** {
 988              		.loc 1 965 0
 989              		.cfi_startproc
ARM GAS  /tmp/cc0JzPHi.s 			page 35


 990              		@ args = 0, pretend = 0, frame = 0
 991              		@ frame_needed = 0, uses_anonymous_args = 0
 992              		@ link register save eliminated.
 993              	.LVL101:
 966:FWLIB/src/stm32f4xx_usart.c ****   /* Check the parameters */
 967:FWLIB/src/stm32f4xx_usart.c ****   assert_param(IS_USART_1236_PERIPH(USARTx)); 
 968:FWLIB/src/stm32f4xx_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 969:FWLIB/src/stm32f4xx_usart.c ****   if (NewState != DISABLE)
 994              		.loc 1 969 0
 995 0000 31B9     		cbnz	r1, .L77
 970:FWLIB/src/stm32f4xx_usart.c ****   {
 971:FWLIB/src/stm32f4xx_usart.c ****     /* Enable the NACK transmission by setting the NACK bit in the CR3 register */
 972:FWLIB/src/stm32f4xx_usart.c ****     USARTx->CR3 |= USART_CR3_NACK;
 973:FWLIB/src/stm32f4xx_usart.c ****   }
 974:FWLIB/src/stm32f4xx_usart.c ****   else
 975:FWLIB/src/stm32f4xx_usart.c ****   {
 976:FWLIB/src/stm32f4xx_usart.c ****     /* Disable the NACK transmission by clearing the NACK bit in the CR3 register */
 977:FWLIB/src/stm32f4xx_usart.c ****     USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_NACK);
 996              		.loc 1 977 0
 997 0002 838A     		ldrh	r3, [r0, #20]
 998 0004 9BB2     		uxth	r3, r3
 999 0006 23F01003 		bic	r3, r3, #16
 1000 000a 9BB2     		uxth	r3, r3
 1001 000c 8382     		strh	r3, [r0, #20]	@ movhi
 1002 000e 7047     		bx	lr
 1003              	.L77:
 972:FWLIB/src/stm32f4xx_usart.c ****   }
 1004              		.loc 1 972 0
 1005 0010 838A     		ldrh	r3, [r0, #20]
 1006 0012 9BB2     		uxth	r3, r3
 1007 0014 43F01003 		orr	r3, r3, #16
 1008 0018 8382     		strh	r3, [r0, #20]	@ movhi
 1009 001a 7047     		bx	lr
 1010              		.cfi_endproc
 1011              	.LFE143:
 1013              		.section	.text.USART_IrDAConfig,"ax",%progbits
 1014              		.align	1
 1015              		.global	USART_IrDAConfig
 1016              		.syntax unified
 1017              		.thumb
 1018              		.thumb_func
 1019              		.fpu fpv4-sp-d16
 1021              	USART_IrDAConfig:
 1022              	.LFB144:
 978:FWLIB/src/stm32f4xx_usart.c ****   }
 979:FWLIB/src/stm32f4xx_usart.c **** }
 980:FWLIB/src/stm32f4xx_usart.c **** 
 981:FWLIB/src/stm32f4xx_usart.c **** /**
 982:FWLIB/src/stm32f4xx_usart.c ****   * @}
 983:FWLIB/src/stm32f4xx_usart.c ****   */
 984:FWLIB/src/stm32f4xx_usart.c **** 
 985:FWLIB/src/stm32f4xx_usart.c **** /** @defgroup USART_Group7 IrDA mode functions
 986:FWLIB/src/stm32f4xx_usart.c ****  *  @brief   IrDA mode functions 
 987:FWLIB/src/stm32f4xx_usart.c ****  *
 988:FWLIB/src/stm32f4xx_usart.c **** @verbatim   
 989:FWLIB/src/stm32f4xx_usart.c ****  ===============================================================================
 990:FWLIB/src/stm32f4xx_usart.c ****                         ##### IrDA mode functions #####
ARM GAS  /tmp/cc0JzPHi.s 			page 36


 991:FWLIB/src/stm32f4xx_usart.c ****  ===============================================================================  
 992:FWLIB/src/stm32f4xx_usart.c ****     [..]
 993:FWLIB/src/stm32f4xx_usart.c ****     This subsection provides a set of functions allowing to manage the USART 
 994:FWLIB/src/stm32f4xx_usart.c ****     IrDA communication.
 995:FWLIB/src/stm32f4xx_usart.c ****     [..]
 996:FWLIB/src/stm32f4xx_usart.c ****     IrDA is a half duplex communication protocol. If the Transmitter is busy, any data
 997:FWLIB/src/stm32f4xx_usart.c ****     on the IrDA receive line will be ignored by the IrDA decoder and if the Receiver 
 998:FWLIB/src/stm32f4xx_usart.c ****     is busy, data on the TX from the USART to IrDA will not be encoded by IrDA.
 999:FWLIB/src/stm32f4xx_usart.c ****     While receiving data, transmission should be avoided as the data to be transmitted
1000:FWLIB/src/stm32f4xx_usart.c ****     could be corrupted.
1001:FWLIB/src/stm32f4xx_usart.c ****     [..]
1002:FWLIB/src/stm32f4xx_usart.c ****     IrDA communication is possible through the following procedure:
1003:FWLIB/src/stm32f4xx_usart.c ****       (#) Program the Baud rate, Word length = 8 bits, Stop bits, Parity, Transmitter/Receiver 
1004:FWLIB/src/stm32f4xx_usart.c ****           modes and hardware flow control values using the USART_Init() function.
1005:FWLIB/src/stm32f4xx_usart.c ****       (#) Enable the USART using the USART_Cmd() function.
1006:FWLIB/src/stm32f4xx_usart.c ****       (#) Configures the IrDA pulse width by configuring the prescaler using  
1007:FWLIB/src/stm32f4xx_usart.c ****           the USART_SetPrescaler() function.
1008:FWLIB/src/stm32f4xx_usart.c ****       (#) Configures the IrDA  USART_IrDAMode_LowPower or USART_IrDAMode_Normal mode
1009:FWLIB/src/stm32f4xx_usart.c ****           using the USART_IrDAConfig() function.
1010:FWLIB/src/stm32f4xx_usart.c ****       (#) Enable the IrDA using the USART_IrDACmd() function.
1011:FWLIB/src/stm32f4xx_usart.c **** 
1012:FWLIB/src/stm32f4xx_usart.c ****       -@- A pulse of width less than two and greater than one PSC period(s) may or may
1013:FWLIB/src/stm32f4xx_usart.c ****           not be rejected.
1014:FWLIB/src/stm32f4xx_usart.c ****       -@- The receiver set up time should be managed by software. The IrDA physical layer
1015:FWLIB/src/stm32f4xx_usart.c ****           specification specifies a minimum of 10 ms delay between transmission and 
1016:FWLIB/src/stm32f4xx_usart.c ****           reception (IrDA is a half duplex protocol).
1017:FWLIB/src/stm32f4xx_usart.c ****       -@- In IrDA mode, the following bits must be kept cleared:
1018:FWLIB/src/stm32f4xx_usart.c ****         (+@) LINEN, STOP and CLKEN bits in the USART_CR2 register.
1019:FWLIB/src/stm32f4xx_usart.c ****         (+@) SCEN and HDSEL bits in the USART_CR3 register.
1020:FWLIB/src/stm32f4xx_usart.c **** 
1021:FWLIB/src/stm32f4xx_usart.c **** @endverbatim
1022:FWLIB/src/stm32f4xx_usart.c ****   * @{
1023:FWLIB/src/stm32f4xx_usart.c ****   */
1024:FWLIB/src/stm32f4xx_usart.c **** 
1025:FWLIB/src/stm32f4xx_usart.c **** /**
1026:FWLIB/src/stm32f4xx_usart.c ****   * @brief  Configures the USART's IrDA interface.
1027:FWLIB/src/stm32f4xx_usart.c ****   * @param  USARTx: where x can be 1, 2, 3, 4, 5, 6, 7 or 8 to select the USART or 
1028:FWLIB/src/stm32f4xx_usart.c ****   *         UART peripheral.
1029:FWLIB/src/stm32f4xx_usart.c ****   * @param  USART_IrDAMode: specifies the IrDA mode.
1030:FWLIB/src/stm32f4xx_usart.c ****   *          This parameter can be one of the following values:
1031:FWLIB/src/stm32f4xx_usart.c ****   *            @arg USART_IrDAMode_LowPower
1032:FWLIB/src/stm32f4xx_usart.c ****   *            @arg USART_IrDAMode_Normal
1033:FWLIB/src/stm32f4xx_usart.c ****   * @retval None
1034:FWLIB/src/stm32f4xx_usart.c ****   */
1035:FWLIB/src/stm32f4xx_usart.c **** void USART_IrDAConfig(USART_TypeDef* USARTx, uint16_t USART_IrDAMode)
1036:FWLIB/src/stm32f4xx_usart.c **** {
 1023              		.loc 1 1036 0
 1024              		.cfi_startproc
 1025              		@ args = 0, pretend = 0, frame = 0
 1026              		@ frame_needed = 0, uses_anonymous_args = 0
 1027              		@ link register save eliminated.
 1028              	.LVL102:
1037:FWLIB/src/stm32f4xx_usart.c ****   /* Check the parameters */
1038:FWLIB/src/stm32f4xx_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
1039:FWLIB/src/stm32f4xx_usart.c ****   assert_param(IS_USART_IRDA_MODE(USART_IrDAMode));
1040:FWLIB/src/stm32f4xx_usart.c ****     
1041:FWLIB/src/stm32f4xx_usart.c ****   USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_IRLP);
ARM GAS  /tmp/cc0JzPHi.s 			page 37


 1029              		.loc 1 1041 0
 1030 0000 838A     		ldrh	r3, [r0, #20]
 1031 0002 9BB2     		uxth	r3, r3
 1032 0004 23F00403 		bic	r3, r3, #4
 1033 0008 9BB2     		uxth	r3, r3
 1034 000a 8382     		strh	r3, [r0, #20]	@ movhi
1042:FWLIB/src/stm32f4xx_usart.c ****   USARTx->CR3 |= USART_IrDAMode;
 1035              		.loc 1 1042 0
 1036 000c 838A     		ldrh	r3, [r0, #20]
 1037 000e 9BB2     		uxth	r3, r3
 1038 0010 1943     		orrs	r1, r1, r3
 1039              	.LVL103:
 1040 0012 8182     		strh	r1, [r0, #20]	@ movhi
 1041 0014 7047     		bx	lr
 1042              		.cfi_endproc
 1043              	.LFE144:
 1045              		.section	.text.USART_IrDACmd,"ax",%progbits
 1046              		.align	1
 1047              		.global	USART_IrDACmd
 1048              		.syntax unified
 1049              		.thumb
 1050              		.thumb_func
 1051              		.fpu fpv4-sp-d16
 1053              	USART_IrDACmd:
 1054              	.LFB145:
1043:FWLIB/src/stm32f4xx_usart.c **** }
1044:FWLIB/src/stm32f4xx_usart.c **** 
1045:FWLIB/src/stm32f4xx_usart.c **** /**
1046:FWLIB/src/stm32f4xx_usart.c ****   * @brief  Enables or disables the USART's IrDA interface.
1047:FWLIB/src/stm32f4xx_usart.c ****   * @param  USARTx: where x can be 1, 2, 3, 4, 5, 6, 7 or 8 to select the USART or 
1048:FWLIB/src/stm32f4xx_usart.c ****   *         UART peripheral.
1049:FWLIB/src/stm32f4xx_usart.c ****   * @param  NewState: new state of the IrDA mode.
1050:FWLIB/src/stm32f4xx_usart.c ****   *          This parameter can be: ENABLE or DISABLE.
1051:FWLIB/src/stm32f4xx_usart.c ****   * @retval None
1052:FWLIB/src/stm32f4xx_usart.c ****   */
1053:FWLIB/src/stm32f4xx_usart.c **** void USART_IrDACmd(USART_TypeDef* USARTx, FunctionalState NewState)
1054:FWLIB/src/stm32f4xx_usart.c **** {
 1055              		.loc 1 1054 0
 1056              		.cfi_startproc
 1057              		@ args = 0, pretend = 0, frame = 0
 1058              		@ frame_needed = 0, uses_anonymous_args = 0
 1059              		@ link register save eliminated.
 1060              	.LVL104:
1055:FWLIB/src/stm32f4xx_usart.c ****   /* Check the parameters */
1056:FWLIB/src/stm32f4xx_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
1057:FWLIB/src/stm32f4xx_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
1058:FWLIB/src/stm32f4xx_usart.c ****     
1059:FWLIB/src/stm32f4xx_usart.c ****   if (NewState != DISABLE)
 1061              		.loc 1 1059 0
 1062 0000 31B9     		cbnz	r1, .L82
1060:FWLIB/src/stm32f4xx_usart.c ****   {
1061:FWLIB/src/stm32f4xx_usart.c ****     /* Enable the IrDA mode by setting the IREN bit in the CR3 register */
1062:FWLIB/src/stm32f4xx_usart.c ****     USARTx->CR3 |= USART_CR3_IREN;
1063:FWLIB/src/stm32f4xx_usart.c ****   }
1064:FWLIB/src/stm32f4xx_usart.c ****   else
1065:FWLIB/src/stm32f4xx_usart.c ****   {
1066:FWLIB/src/stm32f4xx_usart.c ****     /* Disable the IrDA mode by clearing the IREN bit in the CR3 register */
ARM GAS  /tmp/cc0JzPHi.s 			page 38


1067:FWLIB/src/stm32f4xx_usart.c ****     USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_IREN);
 1063              		.loc 1 1067 0
 1064 0002 838A     		ldrh	r3, [r0, #20]
 1065 0004 9BB2     		uxth	r3, r3
 1066 0006 23F00203 		bic	r3, r3, #2
 1067 000a 9BB2     		uxth	r3, r3
 1068 000c 8382     		strh	r3, [r0, #20]	@ movhi
 1069 000e 7047     		bx	lr
 1070              	.L82:
1062:FWLIB/src/stm32f4xx_usart.c ****   }
 1071              		.loc 1 1062 0
 1072 0010 838A     		ldrh	r3, [r0, #20]
 1073 0012 9BB2     		uxth	r3, r3
 1074 0014 43F00203 		orr	r3, r3, #2
 1075 0018 8382     		strh	r3, [r0, #20]	@ movhi
 1076 001a 7047     		bx	lr
 1077              		.cfi_endproc
 1078              	.LFE145:
 1080              		.section	.text.USART_DMACmd,"ax",%progbits
 1081              		.align	1
 1082              		.global	USART_DMACmd
 1083              		.syntax unified
 1084              		.thumb
 1085              		.thumb_func
 1086              		.fpu fpv4-sp-d16
 1088              	USART_DMACmd:
 1089              	.LFB146:
1068:FWLIB/src/stm32f4xx_usart.c ****   }
1069:FWLIB/src/stm32f4xx_usart.c **** }
1070:FWLIB/src/stm32f4xx_usart.c **** 
1071:FWLIB/src/stm32f4xx_usart.c **** /**
1072:FWLIB/src/stm32f4xx_usart.c ****   * @}
1073:FWLIB/src/stm32f4xx_usart.c ****   */
1074:FWLIB/src/stm32f4xx_usart.c **** 
1075:FWLIB/src/stm32f4xx_usart.c **** /** @defgroup USART_Group8 DMA transfers management functions
1076:FWLIB/src/stm32f4xx_usart.c ****  *  @brief   DMA transfers management functions
1077:FWLIB/src/stm32f4xx_usart.c ****  *
1078:FWLIB/src/stm32f4xx_usart.c **** @verbatim   
1079:FWLIB/src/stm32f4xx_usart.c ****  ===============================================================================
1080:FWLIB/src/stm32f4xx_usart.c ****               ##### DMA transfers management functions #####
1081:FWLIB/src/stm32f4xx_usart.c ****  ===============================================================================  
1082:FWLIB/src/stm32f4xx_usart.c **** 
1083:FWLIB/src/stm32f4xx_usart.c **** @endverbatim
1084:FWLIB/src/stm32f4xx_usart.c ****   * @{
1085:FWLIB/src/stm32f4xx_usart.c ****   */
1086:FWLIB/src/stm32f4xx_usart.c ****   
1087:FWLIB/src/stm32f4xx_usart.c **** /**
1088:FWLIB/src/stm32f4xx_usart.c ****   * @brief  Enables or disables the USART's DMA interface.
1089:FWLIB/src/stm32f4xx_usart.c ****   * @param  USARTx: where x can be 1, 2, 3, 4, 5, 6, 7 or 8 to select the USART or 
1090:FWLIB/src/stm32f4xx_usart.c ****   *         UART peripheral.
1091:FWLIB/src/stm32f4xx_usart.c ****   * @param  USART_DMAReq: specifies the DMA request.
1092:FWLIB/src/stm32f4xx_usart.c ****   *          This parameter can be any combination of the following values:
1093:FWLIB/src/stm32f4xx_usart.c ****   *            @arg USART_DMAReq_Tx: USART DMA transmit request
1094:FWLIB/src/stm32f4xx_usart.c ****   *            @arg USART_DMAReq_Rx: USART DMA receive request
1095:FWLIB/src/stm32f4xx_usart.c ****   * @param  NewState: new state of the DMA Request sources.
1096:FWLIB/src/stm32f4xx_usart.c ****   *          This parameter can be: ENABLE or DISABLE.   
1097:FWLIB/src/stm32f4xx_usart.c ****   * @retval None
ARM GAS  /tmp/cc0JzPHi.s 			page 39


1098:FWLIB/src/stm32f4xx_usart.c ****   */
1099:FWLIB/src/stm32f4xx_usart.c **** void USART_DMACmd(USART_TypeDef* USARTx, uint16_t USART_DMAReq, FunctionalState NewState)
1100:FWLIB/src/stm32f4xx_usart.c **** {
 1090              		.loc 1 1100 0
 1091              		.cfi_startproc
 1092              		@ args = 0, pretend = 0, frame = 0
 1093              		@ frame_needed = 0, uses_anonymous_args = 0
 1094              		@ link register save eliminated.
 1095              	.LVL105:
1101:FWLIB/src/stm32f4xx_usart.c ****   /* Check the parameters */
1102:FWLIB/src/stm32f4xx_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
1103:FWLIB/src/stm32f4xx_usart.c ****   assert_param(IS_USART_DMAREQ(USART_DMAReq));  
1104:FWLIB/src/stm32f4xx_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState)); 
1105:FWLIB/src/stm32f4xx_usart.c **** 
1106:FWLIB/src/stm32f4xx_usart.c ****   if (NewState != DISABLE)
 1096              		.loc 1 1106 0
 1097 0000 2AB9     		cbnz	r2, .L86
1107:FWLIB/src/stm32f4xx_usart.c ****   {
1108:FWLIB/src/stm32f4xx_usart.c ****     /* Enable the DMA transfer for selected requests by setting the DMAT and/or
1109:FWLIB/src/stm32f4xx_usart.c ****        DMAR bits in the USART CR3 register */
1110:FWLIB/src/stm32f4xx_usart.c ****     USARTx->CR3 |= USART_DMAReq;
1111:FWLIB/src/stm32f4xx_usart.c ****   }
1112:FWLIB/src/stm32f4xx_usart.c ****   else
1113:FWLIB/src/stm32f4xx_usart.c ****   {
1114:FWLIB/src/stm32f4xx_usart.c ****     /* Disable the DMA transfer for selected requests by clearing the DMAT and/or
1115:FWLIB/src/stm32f4xx_usart.c ****        DMAR bits in the USART CR3 register */
1116:FWLIB/src/stm32f4xx_usart.c ****     USARTx->CR3 &= (uint16_t)~USART_DMAReq;
 1098              		.loc 1 1116 0
 1099 0002 838A     		ldrh	r3, [r0, #20]
 1100 0004 C943     		mvns	r1, r1
 1101              	.LVL106:
 1102 0006 89B2     		uxth	r1, r1
 1103 0008 1940     		ands	r1, r1, r3
 1104 000a 8182     		strh	r1, [r0, #20]	@ movhi
 1105 000c 7047     		bx	lr
 1106              	.LVL107:
 1107              	.L86:
1110:FWLIB/src/stm32f4xx_usart.c ****   }
 1108              		.loc 1 1110 0
 1109 000e 838A     		ldrh	r3, [r0, #20]
 1110 0010 9BB2     		uxth	r3, r3
 1111 0012 1943     		orrs	r1, r1, r3
 1112              	.LVL108:
 1113 0014 8182     		strh	r1, [r0, #20]	@ movhi
 1114 0016 7047     		bx	lr
 1115              		.cfi_endproc
 1116              	.LFE146:
 1118              		.section	.text.USART_ITConfig,"ax",%progbits
 1119              		.align	1
 1120              		.global	USART_ITConfig
 1121              		.syntax unified
 1122              		.thumb
 1123              		.thumb_func
 1124              		.fpu fpv4-sp-d16
 1126              	USART_ITConfig:
 1127              	.LFB147:
1117:FWLIB/src/stm32f4xx_usart.c ****   }
ARM GAS  /tmp/cc0JzPHi.s 			page 40


1118:FWLIB/src/stm32f4xx_usart.c **** }
1119:FWLIB/src/stm32f4xx_usart.c **** 
1120:FWLIB/src/stm32f4xx_usart.c **** /**
1121:FWLIB/src/stm32f4xx_usart.c ****   * @}
1122:FWLIB/src/stm32f4xx_usart.c ****   */
1123:FWLIB/src/stm32f4xx_usart.c ****   
1124:FWLIB/src/stm32f4xx_usart.c **** /** @defgroup USART_Group9 Interrupts and flags management functions
1125:FWLIB/src/stm32f4xx_usart.c ****  *  @brief   Interrupts and flags management functions 
1126:FWLIB/src/stm32f4xx_usart.c ****  *
1127:FWLIB/src/stm32f4xx_usart.c **** @verbatim   
1128:FWLIB/src/stm32f4xx_usart.c ****  ===============================================================================
1129:FWLIB/src/stm32f4xx_usart.c ****             ##### Interrupts and flags management functions #####
1130:FWLIB/src/stm32f4xx_usart.c ****  ===============================================================================  
1131:FWLIB/src/stm32f4xx_usart.c ****     [..]
1132:FWLIB/src/stm32f4xx_usart.c ****     This subsection provides a set of functions allowing to configure the USART 
1133:FWLIB/src/stm32f4xx_usart.c ****     Interrupts sources, DMA channels requests and check or clear the flags or 
1134:FWLIB/src/stm32f4xx_usart.c ****     pending bits status.
1135:FWLIB/src/stm32f4xx_usart.c ****     The user should identify which mode will be used in his application to manage 
1136:FWLIB/src/stm32f4xx_usart.c ****     the communication: Polling mode, Interrupt mode or DMA mode. 
1137:FWLIB/src/stm32f4xx_usart.c ****     
1138:FWLIB/src/stm32f4xx_usart.c ****     *** Polling Mode ***
1139:FWLIB/src/stm32f4xx_usart.c ****     ====================
1140:FWLIB/src/stm32f4xx_usart.c ****     [..]
1141:FWLIB/src/stm32f4xx_usart.c ****     In Polling Mode, the SPI communication can be managed by 10 flags:
1142:FWLIB/src/stm32f4xx_usart.c ****       (#) USART_FLAG_TXE : to indicate the status of the transmit buffer register
1143:FWLIB/src/stm32f4xx_usart.c ****       (#) USART_FLAG_RXNE : to indicate the status of the receive buffer register
1144:FWLIB/src/stm32f4xx_usart.c ****       (#) USART_FLAG_TC : to indicate the status of the transmit operation
1145:FWLIB/src/stm32f4xx_usart.c ****       (#) USART_FLAG_IDLE : to indicate the status of the Idle Line             
1146:FWLIB/src/stm32f4xx_usart.c ****       (#) USART_FLAG_CTS : to indicate the status of the nCTS input
1147:FWLIB/src/stm32f4xx_usart.c ****       (#) USART_FLAG_LBD : to indicate the status of the LIN break detection
1148:FWLIB/src/stm32f4xx_usart.c ****       (#) USART_FLAG_NE : to indicate if a noise error occur
1149:FWLIB/src/stm32f4xx_usart.c ****       (#) USART_FLAG_FE : to indicate if a frame error occur
1150:FWLIB/src/stm32f4xx_usart.c ****       (#) USART_FLAG_PE : to indicate if a parity error occur
1151:FWLIB/src/stm32f4xx_usart.c ****       (#) USART_FLAG_ORE : to indicate if an Overrun error occur
1152:FWLIB/src/stm32f4xx_usart.c ****     [..]
1153:FWLIB/src/stm32f4xx_usart.c ****     In this Mode it is advised to use the following functions:
1154:FWLIB/src/stm32f4xx_usart.c ****       (+) FlagStatus USART_GetFlagStatus(USART_TypeDef* USARTx, uint16_t USART_FLAG);
1155:FWLIB/src/stm32f4xx_usart.c ****       (+) void USART_ClearFlag(USART_TypeDef* USARTx, uint16_t USART_FLAG);
1156:FWLIB/src/stm32f4xx_usart.c **** 
1157:FWLIB/src/stm32f4xx_usart.c ****     *** Interrupt Mode ***
1158:FWLIB/src/stm32f4xx_usart.c ****     ======================
1159:FWLIB/src/stm32f4xx_usart.c ****     [..]
1160:FWLIB/src/stm32f4xx_usart.c ****     In Interrupt Mode, the USART communication can be managed by 8 interrupt sources
1161:FWLIB/src/stm32f4xx_usart.c ****     and 10 pending bits: 
1162:FWLIB/src/stm32f4xx_usart.c **** 
1163:FWLIB/src/stm32f4xx_usart.c ****       (#) Pending Bits:
1164:FWLIB/src/stm32f4xx_usart.c **** 
1165:FWLIB/src/stm32f4xx_usart.c ****         (##) USART_IT_TXE : to indicate the status of the transmit buffer register
1166:FWLIB/src/stm32f4xx_usart.c ****         (##) USART_IT_RXNE : to indicate the status of the receive buffer register
1167:FWLIB/src/stm32f4xx_usart.c ****         (##) USART_IT_TC : to indicate the status of the transmit operation
1168:FWLIB/src/stm32f4xx_usart.c ****         (##) USART_IT_IDLE : to indicate the status of the Idle Line             
1169:FWLIB/src/stm32f4xx_usart.c ****         (##) USART_IT_CTS : to indicate the status of the nCTS input
1170:FWLIB/src/stm32f4xx_usart.c ****         (##) USART_IT_LBD : to indicate the status of the LIN break detection
1171:FWLIB/src/stm32f4xx_usart.c ****         (##) USART_IT_NE : to indicate if a noise error occur
1172:FWLIB/src/stm32f4xx_usart.c ****         (##) USART_IT_FE : to indicate if a frame error occur
1173:FWLIB/src/stm32f4xx_usart.c ****         (##) USART_IT_PE : to indicate if a parity error occur
1174:FWLIB/src/stm32f4xx_usart.c ****         (##) USART_IT_ORE : to indicate if an Overrun error occur
ARM GAS  /tmp/cc0JzPHi.s 			page 41


1175:FWLIB/src/stm32f4xx_usart.c **** 
1176:FWLIB/src/stm32f4xx_usart.c ****       (#) Interrupt Source:
1177:FWLIB/src/stm32f4xx_usart.c **** 
1178:FWLIB/src/stm32f4xx_usart.c ****         (##) USART_IT_TXE : specifies the interrupt source for the Tx buffer empty 
1179:FWLIB/src/stm32f4xx_usart.c ****                             interrupt. 
1180:FWLIB/src/stm32f4xx_usart.c ****         (##) USART_IT_RXNE : specifies the interrupt source for the Rx buffer not 
1181:FWLIB/src/stm32f4xx_usart.c ****                              empty interrupt.
1182:FWLIB/src/stm32f4xx_usart.c ****         (##) USART_IT_TC : specifies the interrupt source for the Transmit complete 
1183:FWLIB/src/stm32f4xx_usart.c ****                            interrupt. 
1184:FWLIB/src/stm32f4xx_usart.c ****         (##) USART_IT_IDLE : specifies the interrupt source for the Idle Line interrupt.           
1185:FWLIB/src/stm32f4xx_usart.c ****         (##) USART_IT_CTS : specifies the interrupt source for the CTS interrupt. 
1186:FWLIB/src/stm32f4xx_usart.c ****         (##) USART_IT_LBD : specifies the interrupt source for the LIN break detection
1187:FWLIB/src/stm32f4xx_usart.c ****                             interrupt. 
1188:FWLIB/src/stm32f4xx_usart.c ****         (##) USART_IT_PE : specifies the interrupt source for the parity error interrupt. 
1189:FWLIB/src/stm32f4xx_usart.c ****         (##) USART_IT_ERR :  specifies the interrupt source for the errors interrupt.
1190:FWLIB/src/stm32f4xx_usart.c **** 
1191:FWLIB/src/stm32f4xx_usart.c ****       -@@- Some parameters are coded in order to use them as interrupt source 
1192:FWLIB/src/stm32f4xx_usart.c ****           or as pending bits.
1193:FWLIB/src/stm32f4xx_usart.c ****     [..]
1194:FWLIB/src/stm32f4xx_usart.c ****     In this Mode it is advised to use the following functions:
1195:FWLIB/src/stm32f4xx_usart.c ****       (+) void USART_ITConfig(USART_TypeDef* USARTx, uint16_t USART_IT, FunctionalState NewState);
1196:FWLIB/src/stm32f4xx_usart.c ****       (+) ITStatus USART_GetITStatus(USART_TypeDef* USARTx, uint16_t USART_IT);
1197:FWLIB/src/stm32f4xx_usart.c ****       (+) void USART_ClearITPendingBit(USART_TypeDef* USARTx, uint16_t USART_IT);
1198:FWLIB/src/stm32f4xx_usart.c **** 
1199:FWLIB/src/stm32f4xx_usart.c ****     *** DMA Mode ***
1200:FWLIB/src/stm32f4xx_usart.c ****     ================
1201:FWLIB/src/stm32f4xx_usart.c ****     [..]
1202:FWLIB/src/stm32f4xx_usart.c ****     In DMA Mode, the USART communication can be managed by 2 DMA Channel requests:
1203:FWLIB/src/stm32f4xx_usart.c ****       (#) USART_DMAReq_Tx: specifies the Tx buffer DMA transfer request
1204:FWLIB/src/stm32f4xx_usart.c ****       (#) USART_DMAReq_Rx: specifies the Rx buffer DMA transfer request
1205:FWLIB/src/stm32f4xx_usart.c ****     [..]
1206:FWLIB/src/stm32f4xx_usart.c ****     In this Mode it is advised to use the following function:
1207:FWLIB/src/stm32f4xx_usart.c ****       (+) void USART_DMACmd(USART_TypeDef* USARTx, uint16_t USART_DMAReq, FunctionalState NewState)
1208:FWLIB/src/stm32f4xx_usart.c **** 
1209:FWLIB/src/stm32f4xx_usart.c **** @endverbatim
1210:FWLIB/src/stm32f4xx_usart.c ****   * @{
1211:FWLIB/src/stm32f4xx_usart.c ****   */
1212:FWLIB/src/stm32f4xx_usart.c **** 
1213:FWLIB/src/stm32f4xx_usart.c **** /**
1214:FWLIB/src/stm32f4xx_usart.c ****   * @brief  Enables or disables the specified USART interrupts.
1215:FWLIB/src/stm32f4xx_usart.c ****   * @param  USARTx: where x can be 1, 2, 3, 4, 5, 6, 7 or 8 to select the USART or 
1216:FWLIB/src/stm32f4xx_usart.c ****   *         UART peripheral.
1217:FWLIB/src/stm32f4xx_usart.c ****   * @param  USART_IT: specifies the USART interrupt sources to be enabled or disabled.
1218:FWLIB/src/stm32f4xx_usart.c ****   *          This parameter can be one of the following values:
1219:FWLIB/src/stm32f4xx_usart.c ****   *            @arg USART_IT_CTS:  CTS change interrupt
1220:FWLIB/src/stm32f4xx_usart.c ****   *            @arg USART_IT_LBD:  LIN Break detection interrupt
1221:FWLIB/src/stm32f4xx_usart.c ****   *            @arg USART_IT_TXE:  Transmit Data Register empty interrupt
1222:FWLIB/src/stm32f4xx_usart.c ****   *            @arg USART_IT_TC:   Transmission complete interrupt
1223:FWLIB/src/stm32f4xx_usart.c ****   *            @arg USART_IT_RXNE: Receive Data register not empty interrupt
1224:FWLIB/src/stm32f4xx_usart.c ****   *            @arg USART_IT_IDLE: Idle line detection interrupt
1225:FWLIB/src/stm32f4xx_usart.c ****   *            @arg USART_IT_PE:   Parity Error interrupt
1226:FWLIB/src/stm32f4xx_usart.c ****   *            @arg USART_IT_ERR:  Error interrupt(Frame error, noise error, overrun error)
1227:FWLIB/src/stm32f4xx_usart.c ****   * @param  NewState: new state of the specified USARTx interrupts.
1228:FWLIB/src/stm32f4xx_usart.c ****   *          This parameter can be: ENABLE or DISABLE.
1229:FWLIB/src/stm32f4xx_usart.c ****   * @retval None
1230:FWLIB/src/stm32f4xx_usart.c ****   */
1231:FWLIB/src/stm32f4xx_usart.c **** void USART_ITConfig(USART_TypeDef* USARTx, uint16_t USART_IT, FunctionalState NewState)
ARM GAS  /tmp/cc0JzPHi.s 			page 42


1232:FWLIB/src/stm32f4xx_usart.c **** {
 1128              		.loc 1 1232 0
 1129              		.cfi_startproc
 1130              		@ args = 0, pretend = 0, frame = 0
 1131              		@ frame_needed = 0, uses_anonymous_args = 0
 1132              		@ link register save eliminated.
 1133              	.LVL109:
 1134 0000 10B4     		push	{r4}
 1135              	.LCFI7:
 1136              		.cfi_def_cfa_offset 4
 1137              		.cfi_offset 4, -4
 1138              	.LVL110:
1233:FWLIB/src/stm32f4xx_usart.c ****   uint32_t usartreg = 0x00, itpos = 0x00, itmask = 0x00;
1234:FWLIB/src/stm32f4xx_usart.c ****   uint32_t usartxbase = 0x00;
1235:FWLIB/src/stm32f4xx_usart.c ****   /* Check the parameters */
1236:FWLIB/src/stm32f4xx_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
1237:FWLIB/src/stm32f4xx_usart.c ****   assert_param(IS_USART_CONFIG_IT(USART_IT));
1238:FWLIB/src/stm32f4xx_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
1239:FWLIB/src/stm32f4xx_usart.c **** 
1240:FWLIB/src/stm32f4xx_usart.c ****   /* The CTS interrupt is not available for UART4 and UART5 */
1241:FWLIB/src/stm32f4xx_usart.c ****   if (USART_IT == USART_IT_CTS)
1242:FWLIB/src/stm32f4xx_usart.c ****   {
1243:FWLIB/src/stm32f4xx_usart.c ****     assert_param(IS_USART_1236_PERIPH(USARTx));
1244:FWLIB/src/stm32f4xx_usart.c ****   } 
1245:FWLIB/src/stm32f4xx_usart.c ****     
1246:FWLIB/src/stm32f4xx_usart.c ****   usartxbase = (uint32_t)USARTx;
1247:FWLIB/src/stm32f4xx_usart.c **** 
1248:FWLIB/src/stm32f4xx_usart.c ****   /* Get the USART register index */
1249:FWLIB/src/stm32f4xx_usart.c ****   usartreg = (((uint8_t)USART_IT) >> 0x05);
 1139              		.loc 1 1249 0
 1140 0002 C1F34214 		ubfx	r4, r1, #5, #3
 1141              	.LVL111:
1250:FWLIB/src/stm32f4xx_usart.c **** 
1251:FWLIB/src/stm32f4xx_usart.c ****   /* Get the interrupt position */
1252:FWLIB/src/stm32f4xx_usart.c ****   itpos = USART_IT & IT_MASK;
 1142              		.loc 1 1252 0
 1143 0006 01F01F01 		and	r1, r1, #31
 1144              	.LVL112:
1253:FWLIB/src/stm32f4xx_usart.c ****   itmask = (((uint32_t)0x01) << itpos);
 1145              		.loc 1 1253 0
 1146 000a 0123     		movs	r3, #1
 1147 000c 03FA01F1 		lsl	r1, r3, r1
 1148              	.LVL113:
1254:FWLIB/src/stm32f4xx_usart.c ****     
1255:FWLIB/src/stm32f4xx_usart.c ****   if (usartreg == 0x01) /* The IT is in CR1 register */
 1149              		.loc 1 1255 0
 1150 0010 9C42     		cmp	r4, r3
 1151 0012 0AD0     		beq	.L94
1256:FWLIB/src/stm32f4xx_usart.c ****   {
1257:FWLIB/src/stm32f4xx_usart.c ****     usartxbase += 0x0C;
1258:FWLIB/src/stm32f4xx_usart.c ****   }
1259:FWLIB/src/stm32f4xx_usart.c ****   else if (usartreg == 0x02) /* The IT is in CR2 register */
 1152              		.loc 1 1259 0
 1153 0014 022C     		cmp	r4, #2
 1154 0016 0AD0     		beq	.L95
1260:FWLIB/src/stm32f4xx_usart.c ****   {
1261:FWLIB/src/stm32f4xx_usart.c ****     usartxbase += 0x10;
ARM GAS  /tmp/cc0JzPHi.s 			page 43


1262:FWLIB/src/stm32f4xx_usart.c ****   }
1263:FWLIB/src/stm32f4xx_usart.c ****   else /* The IT is in CR3 register */
1264:FWLIB/src/stm32f4xx_usart.c ****   {
1265:FWLIB/src/stm32f4xx_usart.c ****     usartxbase += 0x14; 
 1155              		.loc 1 1265 0
 1156 0018 1430     		adds	r0, r0, #20
 1157              	.LVL114:
 1158              	.L89:
1266:FWLIB/src/stm32f4xx_usart.c ****   }
1267:FWLIB/src/stm32f4xx_usart.c ****   if (NewState != DISABLE)
 1159              		.loc 1 1267 0
 1160 001a 52B9     		cbnz	r2, .L96
1268:FWLIB/src/stm32f4xx_usart.c ****   {
1269:FWLIB/src/stm32f4xx_usart.c ****     *(__IO uint32_t*)usartxbase  |= itmask;
1270:FWLIB/src/stm32f4xx_usart.c ****   }
1271:FWLIB/src/stm32f4xx_usart.c ****   else
1272:FWLIB/src/stm32f4xx_usart.c ****   {
1273:FWLIB/src/stm32f4xx_usart.c ****     *(__IO uint32_t*)usartxbase &= ~itmask;
 1161              		.loc 1 1273 0
 1162 001c 0368     		ldr	r3, [r0]
 1163 001e 23EA0101 		bic	r1, r3, r1
 1164              	.LVL115:
 1165 0022 0160     		str	r1, [r0]
 1166              	.L87:
1274:FWLIB/src/stm32f4xx_usart.c ****   }
1275:FWLIB/src/stm32f4xx_usart.c **** }
 1167              		.loc 1 1275 0
 1168 0024 5DF8044B 		ldr	r4, [sp], #4
 1169              	.LCFI8:
 1170              		.cfi_remember_state
 1171              		.cfi_restore 4
 1172              		.cfi_def_cfa_offset 0
 1173              	.LVL116:
 1174 0028 7047     		bx	lr
 1175              	.LVL117:
 1176              	.L94:
 1177              	.LCFI9:
 1178              		.cfi_restore_state
1257:FWLIB/src/stm32f4xx_usart.c ****   }
 1179              		.loc 1 1257 0
 1180 002a 0C30     		adds	r0, r0, #12
 1181              	.LVL118:
 1182 002c F5E7     		b	.L89
 1183              	.LVL119:
 1184              	.L95:
1261:FWLIB/src/stm32f4xx_usart.c ****   }
 1185              		.loc 1 1261 0
 1186 002e 1030     		adds	r0, r0, #16
 1187              	.LVL120:
 1188 0030 F3E7     		b	.L89
 1189              	.LVL121:
 1190              	.L96:
1269:FWLIB/src/stm32f4xx_usart.c ****   }
 1191              		.loc 1 1269 0
 1192 0032 0368     		ldr	r3, [r0]
 1193 0034 1943     		orrs	r1, r1, r3
 1194              	.LVL122:
ARM GAS  /tmp/cc0JzPHi.s 			page 44


 1195 0036 0160     		str	r1, [r0]
 1196 0038 F4E7     		b	.L87
 1197              		.cfi_endproc
 1198              	.LFE147:
 1200              		.section	.text.USART_GetFlagStatus,"ax",%progbits
 1201              		.align	1
 1202              		.global	USART_GetFlagStatus
 1203              		.syntax unified
 1204              		.thumb
 1205              		.thumb_func
 1206              		.fpu fpv4-sp-d16
 1208              	USART_GetFlagStatus:
 1209              	.LFB148:
1276:FWLIB/src/stm32f4xx_usart.c **** 
1277:FWLIB/src/stm32f4xx_usart.c **** /**
1278:FWLIB/src/stm32f4xx_usart.c ****   * @brief  Checks whether the specified USART flag is set or not.
1279:FWLIB/src/stm32f4xx_usart.c ****   * @param  USARTx: where x can be 1, 2, 3, 4, 5, 6, 7 or 8 to select the USART or 
1280:FWLIB/src/stm32f4xx_usart.c ****   *         UART peripheral.
1281:FWLIB/src/stm32f4xx_usart.c ****   * @param  USART_FLAG: specifies the flag to check.
1282:FWLIB/src/stm32f4xx_usart.c ****   *          This parameter can be one of the following values:
1283:FWLIB/src/stm32f4xx_usart.c ****   *            @arg USART_FLAG_CTS:  CTS Change flag (not available for UART4 and UART5)
1284:FWLIB/src/stm32f4xx_usart.c ****   *            @arg USART_FLAG_LBD:  LIN Break detection flag
1285:FWLIB/src/stm32f4xx_usart.c ****   *            @arg USART_FLAG_TXE:  Transmit data register empty flag
1286:FWLIB/src/stm32f4xx_usart.c ****   *            @arg USART_FLAG_TC:   Transmission Complete flag
1287:FWLIB/src/stm32f4xx_usart.c ****   *            @arg USART_FLAG_RXNE: Receive data register not empty flag
1288:FWLIB/src/stm32f4xx_usart.c ****   *            @arg USART_FLAG_IDLE: Idle Line detection flag
1289:FWLIB/src/stm32f4xx_usart.c ****   *            @arg USART_FLAG_ORE:  OverRun Error flag
1290:FWLIB/src/stm32f4xx_usart.c ****   *            @arg USART_FLAG_NE:   Noise Error flag
1291:FWLIB/src/stm32f4xx_usart.c ****   *            @arg USART_FLAG_FE:   Framing Error flag
1292:FWLIB/src/stm32f4xx_usart.c ****   *            @arg USART_FLAG_PE:   Parity Error flag
1293:FWLIB/src/stm32f4xx_usart.c ****   * @retval The new state of USART_FLAG (SET or RESET).
1294:FWLIB/src/stm32f4xx_usart.c ****   */
1295:FWLIB/src/stm32f4xx_usart.c **** FlagStatus USART_GetFlagStatus(USART_TypeDef* USARTx, uint16_t USART_FLAG)
1296:FWLIB/src/stm32f4xx_usart.c **** {
 1210              		.loc 1 1296 0
 1211              		.cfi_startproc
 1212              		@ args = 0, pretend = 0, frame = 0
 1213              		@ frame_needed = 0, uses_anonymous_args = 0
 1214              		@ link register save eliminated.
 1215              	.LVL123:
1297:FWLIB/src/stm32f4xx_usart.c ****   FlagStatus bitstatus = RESET;
1298:FWLIB/src/stm32f4xx_usart.c ****   /* Check the parameters */
1299:FWLIB/src/stm32f4xx_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
1300:FWLIB/src/stm32f4xx_usart.c ****   assert_param(IS_USART_FLAG(USART_FLAG));
1301:FWLIB/src/stm32f4xx_usart.c **** 
1302:FWLIB/src/stm32f4xx_usart.c ****   /* The CTS flag is not available for UART4 and UART5 */
1303:FWLIB/src/stm32f4xx_usart.c ****   if (USART_FLAG == USART_FLAG_CTS)
1304:FWLIB/src/stm32f4xx_usart.c ****   {
1305:FWLIB/src/stm32f4xx_usart.c ****     assert_param(IS_USART_1236_PERIPH(USARTx));
1306:FWLIB/src/stm32f4xx_usart.c ****   } 
1307:FWLIB/src/stm32f4xx_usart.c ****     
1308:FWLIB/src/stm32f4xx_usart.c ****   if ((USARTx->SR & USART_FLAG) != (uint16_t)RESET)
 1216              		.loc 1 1308 0
 1217 0000 0388     		ldrh	r3, [r0]
 1218 0002 1942     		tst	r1, r3
 1219 0004 01D1     		bne	.L100
1309:FWLIB/src/stm32f4xx_usart.c ****   {
ARM GAS  /tmp/cc0JzPHi.s 			page 45


1310:FWLIB/src/stm32f4xx_usart.c ****     bitstatus = SET;
1311:FWLIB/src/stm32f4xx_usart.c ****   }
1312:FWLIB/src/stm32f4xx_usart.c ****   else
1313:FWLIB/src/stm32f4xx_usart.c ****   {
1314:FWLIB/src/stm32f4xx_usart.c ****     bitstatus = RESET;
 1220              		.loc 1 1314 0
 1221 0006 0020     		movs	r0, #0
 1222              	.LVL124:
1315:FWLIB/src/stm32f4xx_usart.c ****   }
1316:FWLIB/src/stm32f4xx_usart.c ****   return bitstatus;
1317:FWLIB/src/stm32f4xx_usart.c **** }
 1223              		.loc 1 1317 0
 1224 0008 7047     		bx	lr
 1225              	.LVL125:
 1226              	.L100:
1310:FWLIB/src/stm32f4xx_usart.c ****   }
 1227              		.loc 1 1310 0
 1228 000a 0120     		movs	r0, #1
 1229              	.LVL126:
 1230 000c 7047     		bx	lr
 1231              		.cfi_endproc
 1232              	.LFE148:
 1234              		.section	.text.USART_ClearFlag,"ax",%progbits
 1235              		.align	1
 1236              		.global	USART_ClearFlag
 1237              		.syntax unified
 1238              		.thumb
 1239              		.thumb_func
 1240              		.fpu fpv4-sp-d16
 1242              	USART_ClearFlag:
 1243              	.LFB149:
1318:FWLIB/src/stm32f4xx_usart.c **** 
1319:FWLIB/src/stm32f4xx_usart.c **** /**
1320:FWLIB/src/stm32f4xx_usart.c ****   * @brief  Clears the USARTx's pending flags.
1321:FWLIB/src/stm32f4xx_usart.c ****   * @param  USARTx: where x can be 1, 2, 3, 4, 5, 6, 7 or 8 to select the USART or 
1322:FWLIB/src/stm32f4xx_usart.c ****   *         UART peripheral.
1323:FWLIB/src/stm32f4xx_usart.c ****   * @param  USART_FLAG: specifies the flag to clear.
1324:FWLIB/src/stm32f4xx_usart.c ****   *          This parameter can be any combination of the following values:
1325:FWLIB/src/stm32f4xx_usart.c ****   *            @arg USART_FLAG_CTS:  CTS Change flag (not available for UART4 and UART5).
1326:FWLIB/src/stm32f4xx_usart.c ****   *            @arg USART_FLAG_LBD:  LIN Break detection flag.
1327:FWLIB/src/stm32f4xx_usart.c ****   *            @arg USART_FLAG_TC:   Transmission Complete flag.
1328:FWLIB/src/stm32f4xx_usart.c ****   *            @arg USART_FLAG_RXNE: Receive data register not empty flag.
1329:FWLIB/src/stm32f4xx_usart.c ****   *   
1330:FWLIB/src/stm32f4xx_usart.c ****   * @note   PE (Parity error), FE (Framing error), NE (Noise error), ORE (OverRun 
1331:FWLIB/src/stm32f4xx_usart.c ****   *          error) and IDLE (Idle line detected) flags are cleared by software 
1332:FWLIB/src/stm32f4xx_usart.c ****   *          sequence: a read operation to USART_SR register (USART_GetFlagStatus()) 
1333:FWLIB/src/stm32f4xx_usart.c ****   *          followed by a read operation to USART_DR register (USART_ReceiveData()).
1334:FWLIB/src/stm32f4xx_usart.c ****   * @note   RXNE flag can be also cleared by a read to the USART_DR register 
1335:FWLIB/src/stm32f4xx_usart.c ****   *          (USART_ReceiveData()).
1336:FWLIB/src/stm32f4xx_usart.c ****   * @note   TC flag can be also cleared by software sequence: a read operation to 
1337:FWLIB/src/stm32f4xx_usart.c ****   *          USART_SR register (USART_GetFlagStatus()) followed by a write operation
1338:FWLIB/src/stm32f4xx_usart.c ****   *          to USART_DR register (USART_SendData()).
1339:FWLIB/src/stm32f4xx_usart.c ****   * @note   TXE flag is cleared only by a write to the USART_DR register 
1340:FWLIB/src/stm32f4xx_usart.c ****   *          (USART_SendData()).
1341:FWLIB/src/stm32f4xx_usart.c ****   *   
1342:FWLIB/src/stm32f4xx_usart.c ****   * @retval None
1343:FWLIB/src/stm32f4xx_usart.c ****   */
ARM GAS  /tmp/cc0JzPHi.s 			page 46


1344:FWLIB/src/stm32f4xx_usart.c **** void USART_ClearFlag(USART_TypeDef* USARTx, uint16_t USART_FLAG)
1345:FWLIB/src/stm32f4xx_usart.c **** {
 1244              		.loc 1 1345 0
 1245              		.cfi_startproc
 1246              		@ args = 0, pretend = 0, frame = 0
 1247              		@ frame_needed = 0, uses_anonymous_args = 0
 1248              		@ link register save eliminated.
 1249              	.LVL127:
1346:FWLIB/src/stm32f4xx_usart.c ****   /* Check the parameters */
1347:FWLIB/src/stm32f4xx_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
1348:FWLIB/src/stm32f4xx_usart.c ****   assert_param(IS_USART_CLEAR_FLAG(USART_FLAG));
1349:FWLIB/src/stm32f4xx_usart.c **** 
1350:FWLIB/src/stm32f4xx_usart.c ****   /* The CTS flag is not available for UART4 and UART5 */
1351:FWLIB/src/stm32f4xx_usart.c ****   if ((USART_FLAG & USART_FLAG_CTS) == USART_FLAG_CTS)
1352:FWLIB/src/stm32f4xx_usart.c ****   {
1353:FWLIB/src/stm32f4xx_usart.c ****     assert_param(IS_USART_1236_PERIPH(USARTx));
1354:FWLIB/src/stm32f4xx_usart.c ****   } 
1355:FWLIB/src/stm32f4xx_usart.c ****        
1356:FWLIB/src/stm32f4xx_usart.c ****   USARTx->SR = (uint16_t)~USART_FLAG;
 1250              		.loc 1 1356 0
 1251 0000 C943     		mvns	r1, r1
 1252              	.LVL128:
 1253 0002 89B2     		uxth	r1, r1
 1254 0004 0180     		strh	r1, [r0]	@ movhi
 1255 0006 7047     		bx	lr
 1256              		.cfi_endproc
 1257              	.LFE149:
 1259              		.section	.text.USART_GetITStatus,"ax",%progbits
 1260              		.align	1
 1261              		.global	USART_GetITStatus
 1262              		.syntax unified
 1263              		.thumb
 1264              		.thumb_func
 1265              		.fpu fpv4-sp-d16
 1267              	USART_GetITStatus:
 1268              	.LFB150:
1357:FWLIB/src/stm32f4xx_usart.c **** }
1358:FWLIB/src/stm32f4xx_usart.c **** 
1359:FWLIB/src/stm32f4xx_usart.c **** /**
1360:FWLIB/src/stm32f4xx_usart.c ****   * @brief  Checks whether the specified USART interrupt has occurred or not.
1361:FWLIB/src/stm32f4xx_usart.c ****   * @param  USARTx: where x can be 1, 2, 3, 4, 5, 6, 7 or 8 to select the USART or 
1362:FWLIB/src/stm32f4xx_usart.c ****   *         UART peripheral.
1363:FWLIB/src/stm32f4xx_usart.c ****   * @param  USART_IT: specifies the USART interrupt source to check.
1364:FWLIB/src/stm32f4xx_usart.c ****   *          This parameter can be one of the following values:
1365:FWLIB/src/stm32f4xx_usart.c ****   *            @arg USART_IT_CTS:  CTS change interrupt (not available for UART4 and UART5)
1366:FWLIB/src/stm32f4xx_usart.c ****   *            @arg USART_IT_LBD:  LIN Break detection interrupt
1367:FWLIB/src/stm32f4xx_usart.c ****   *            @arg USART_IT_TXE:  Transmit Data Register empty interrupt
1368:FWLIB/src/stm32f4xx_usart.c ****   *            @arg USART_IT_TC:   Transmission complete interrupt
1369:FWLIB/src/stm32f4xx_usart.c ****   *            @arg USART_IT_RXNE: Receive Data register not empty interrupt
1370:FWLIB/src/stm32f4xx_usart.c ****   *            @arg USART_IT_IDLE: Idle line detection interrupt
1371:FWLIB/src/stm32f4xx_usart.c ****   *            @arg USART_IT_ORE_RX : OverRun Error interrupt if the RXNEIE bit is set
1372:FWLIB/src/stm32f4xx_usart.c ****   *            @arg USART_IT_ORE_ER : OverRun Error interrupt if the EIE bit is set  
1373:FWLIB/src/stm32f4xx_usart.c ****   *            @arg USART_IT_NE:   Noise Error interrupt
1374:FWLIB/src/stm32f4xx_usart.c ****   *            @arg USART_IT_FE:   Framing Error interrupt
1375:FWLIB/src/stm32f4xx_usart.c ****   *            @arg USART_IT_PE:   Parity Error interrupt
1376:FWLIB/src/stm32f4xx_usart.c ****   * @retval The new state of USART_IT (SET or RESET).
1377:FWLIB/src/stm32f4xx_usart.c ****   */
ARM GAS  /tmp/cc0JzPHi.s 			page 47


1378:FWLIB/src/stm32f4xx_usart.c **** ITStatus USART_GetITStatus(USART_TypeDef* USARTx, uint16_t USART_IT)
1379:FWLIB/src/stm32f4xx_usart.c **** {
 1269              		.loc 1 1379 0
 1270              		.cfi_startproc
 1271              		@ args = 0, pretend = 0, frame = 0
 1272              		@ frame_needed = 0, uses_anonymous_args = 0
 1273              		@ link register save eliminated.
 1274              	.LVL129:
 1275 0000 10B4     		push	{r4}
 1276              	.LCFI10:
 1277              		.cfi_def_cfa_offset 4
 1278              		.cfi_offset 4, -4
 1279              	.LVL130:
1380:FWLIB/src/stm32f4xx_usart.c ****   uint32_t bitpos = 0x00, itmask = 0x00, usartreg = 0x00;
1381:FWLIB/src/stm32f4xx_usart.c ****   ITStatus bitstatus = RESET;
1382:FWLIB/src/stm32f4xx_usart.c ****   /* Check the parameters */
1383:FWLIB/src/stm32f4xx_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
1384:FWLIB/src/stm32f4xx_usart.c ****   assert_param(IS_USART_GET_IT(USART_IT)); 
1385:FWLIB/src/stm32f4xx_usart.c **** 
1386:FWLIB/src/stm32f4xx_usart.c ****   /* The CTS interrupt is not available for UART4 and UART5 */ 
1387:FWLIB/src/stm32f4xx_usart.c ****   if (USART_IT == USART_IT_CTS)
1388:FWLIB/src/stm32f4xx_usart.c ****   {
1389:FWLIB/src/stm32f4xx_usart.c ****     assert_param(IS_USART_1236_PERIPH(USARTx));
1390:FWLIB/src/stm32f4xx_usart.c ****   } 
1391:FWLIB/src/stm32f4xx_usart.c ****     
1392:FWLIB/src/stm32f4xx_usart.c ****   /* Get the USART register index */
1393:FWLIB/src/stm32f4xx_usart.c ****   usartreg = (((uint8_t)USART_IT) >> 0x05);
 1280              		.loc 1 1393 0
 1281 0002 C1F34212 		ubfx	r2, r1, #5, #3
 1282              	.LVL131:
1394:FWLIB/src/stm32f4xx_usart.c ****   /* Get the interrupt position */
1395:FWLIB/src/stm32f4xx_usart.c ****   itmask = USART_IT & IT_MASK;
 1283              		.loc 1 1395 0
 1284 0006 01F01F04 		and	r4, r1, #31
 1285              	.LVL132:
1396:FWLIB/src/stm32f4xx_usart.c ****   itmask = (uint32_t)0x01 << itmask;
 1286              		.loc 1 1396 0
 1287 000a 0123     		movs	r3, #1
 1288 000c A340     		lsls	r3, r3, r4
 1289              	.LVL133:
1397:FWLIB/src/stm32f4xx_usart.c ****   
1398:FWLIB/src/stm32f4xx_usart.c ****   if (usartreg == 0x01) /* The IT  is in CR1 register */
 1290              		.loc 1 1398 0
 1291 000e 012A     		cmp	r2, #1
 1292 0010 0FD0     		beq	.L110
1399:FWLIB/src/stm32f4xx_usart.c ****   {
1400:FWLIB/src/stm32f4xx_usart.c ****     itmask &= USARTx->CR1;
1401:FWLIB/src/stm32f4xx_usart.c ****   }
1402:FWLIB/src/stm32f4xx_usart.c ****   else if (usartreg == 0x02) /* The IT  is in CR2 register */
 1293              		.loc 1 1402 0
 1294 0012 022A     		cmp	r2, #2
 1295 0014 11D0     		beq	.L111
1403:FWLIB/src/stm32f4xx_usart.c ****   {
1404:FWLIB/src/stm32f4xx_usart.c ****     itmask &= USARTx->CR2;
1405:FWLIB/src/stm32f4xx_usart.c ****   }
1406:FWLIB/src/stm32f4xx_usart.c ****   else /* The IT  is in CR3 register */
1407:FWLIB/src/stm32f4xx_usart.c ****   {
ARM GAS  /tmp/cc0JzPHi.s 			page 48


1408:FWLIB/src/stm32f4xx_usart.c ****     itmask &= USARTx->CR3;
 1296              		.loc 1 1408 0
 1297 0016 828A     		ldrh	r2, [r0, #20]
 1298              	.LVL134:
 1299 0018 92B2     		uxth	r2, r2
 1300 001a 1340     		ands	r3, r3, r2
 1301              	.LVL135:
 1302              	.L104:
1409:FWLIB/src/stm32f4xx_usart.c ****   }
1410:FWLIB/src/stm32f4xx_usart.c ****   
1411:FWLIB/src/stm32f4xx_usart.c ****   bitpos = USART_IT >> 0x08;
 1303              		.loc 1 1411 0
 1304 001c 090A     		lsrs	r1, r1, #8
 1305              	.LVL136:
1412:FWLIB/src/stm32f4xx_usart.c ****   bitpos = (uint32_t)0x01 << bitpos;
 1306              		.loc 1 1412 0
 1307 001e 0122     		movs	r2, #1
 1308 0020 02FA01F1 		lsl	r1, r2, r1
 1309              	.LVL137:
1413:FWLIB/src/stm32f4xx_usart.c ****   bitpos &= USARTx->SR;
 1310              		.loc 1 1413 0
 1311 0024 0288     		ldrh	r2, [r0]
 1312 0026 92B2     		uxth	r2, r2
 1313 0028 1140     		ands	r1, r1, r2
 1314              	.LVL138:
1414:FWLIB/src/stm32f4xx_usart.c ****   if ((itmask != (uint16_t)RESET)&&(bitpos != (uint16_t)RESET))
 1315              		.loc 1 1414 0
 1316 002a 53B1     		cbz	r3, .L107
 1317              		.loc 1 1414 0 is_stmt 0 discriminator 1
 1318 002c 69B9     		cbnz	r1, .L108
1415:FWLIB/src/stm32f4xx_usart.c ****   {
1416:FWLIB/src/stm32f4xx_usart.c ****     bitstatus = SET;
1417:FWLIB/src/stm32f4xx_usart.c ****   }
1418:FWLIB/src/stm32f4xx_usart.c ****   else
1419:FWLIB/src/stm32f4xx_usart.c ****   {
1420:FWLIB/src/stm32f4xx_usart.c ****     bitstatus = RESET;
 1319              		.loc 1 1420 0 is_stmt 1
 1320 002e 0020     		movs	r0, #0
 1321              	.LVL139:
 1322 0030 08E0     		b	.L106
 1323              	.LVL140:
 1324              	.L110:
1400:FWLIB/src/stm32f4xx_usart.c ****   }
 1325              		.loc 1 1400 0
 1326 0032 8289     		ldrh	r2, [r0, #12]
 1327              	.LVL141:
 1328 0034 92B2     		uxth	r2, r2
 1329 0036 1340     		ands	r3, r3, r2
 1330              	.LVL142:
 1331 0038 F0E7     		b	.L104
 1332              	.LVL143:
 1333              	.L111:
1404:FWLIB/src/stm32f4xx_usart.c ****   }
 1334              		.loc 1 1404 0
 1335 003a 028A     		ldrh	r2, [r0, #16]
 1336              	.LVL144:
 1337 003c 92B2     		uxth	r2, r2
ARM GAS  /tmp/cc0JzPHi.s 			page 49


 1338 003e 1340     		ands	r3, r3, r2
 1339              	.LVL145:
 1340 0040 ECE7     		b	.L104
 1341              	.LVL146:
 1342              	.L107:
 1343              		.loc 1 1420 0
 1344 0042 0020     		movs	r0, #0
 1345              	.LVL147:
 1346              	.L106:
1421:FWLIB/src/stm32f4xx_usart.c ****   }
1422:FWLIB/src/stm32f4xx_usart.c ****   
1423:FWLIB/src/stm32f4xx_usart.c ****   return bitstatus;  
1424:FWLIB/src/stm32f4xx_usart.c **** }
 1347              		.loc 1 1424 0
 1348 0044 5DF8044B 		ldr	r4, [sp], #4
 1349              	.LCFI11:
 1350              		.cfi_remember_state
 1351              		.cfi_restore 4
 1352              		.cfi_def_cfa_offset 0
 1353 0048 7047     		bx	lr
 1354              	.LVL148:
 1355              	.L108:
 1356              	.LCFI12:
 1357              		.cfi_restore_state
1416:FWLIB/src/stm32f4xx_usart.c ****   }
 1358              		.loc 1 1416 0
 1359 004a 0120     		movs	r0, #1
 1360              	.LVL149:
 1361 004c FAE7     		b	.L106
 1362              		.cfi_endproc
 1363              	.LFE150:
 1365              		.section	.text.USART_ClearITPendingBit,"ax",%progbits
 1366              		.align	1
 1367              		.global	USART_ClearITPendingBit
 1368              		.syntax unified
 1369              		.thumb
 1370              		.thumb_func
 1371              		.fpu fpv4-sp-d16
 1373              	USART_ClearITPendingBit:
 1374              	.LFB151:
1425:FWLIB/src/stm32f4xx_usart.c **** 
1426:FWLIB/src/stm32f4xx_usart.c **** /**
1427:FWLIB/src/stm32f4xx_usart.c ****   * @brief  Clears the USARTx's interrupt pending bits.
1428:FWLIB/src/stm32f4xx_usart.c ****   * @param  USARTx: where x can be 1, 2, 3, 4, 5, 6, 7 or 8 to select the USART or 
1429:FWLIB/src/stm32f4xx_usart.c ****   *         UART peripheral.
1430:FWLIB/src/stm32f4xx_usart.c ****   * @param  USART_IT: specifies the interrupt pending bit to clear.
1431:FWLIB/src/stm32f4xx_usart.c ****   *          This parameter can be one of the following values:
1432:FWLIB/src/stm32f4xx_usart.c ****   *            @arg USART_IT_CTS:  CTS change interrupt (not available for UART4 and UART5)
1433:FWLIB/src/stm32f4xx_usart.c ****   *            @arg USART_IT_LBD:  LIN Break detection interrupt
1434:FWLIB/src/stm32f4xx_usart.c ****   *            @arg USART_IT_TC:   Transmission complete interrupt. 
1435:FWLIB/src/stm32f4xx_usart.c ****   *            @arg USART_IT_RXNE: Receive Data register not empty interrupt.
1436:FWLIB/src/stm32f4xx_usart.c ****   *
1437:FWLIB/src/stm32f4xx_usart.c ****   * @note   PE (Parity error), FE (Framing error), NE (Noise error), ORE (OverRun 
1438:FWLIB/src/stm32f4xx_usart.c ****   *          error) and IDLE (Idle line detected) pending bits are cleared by 
1439:FWLIB/src/stm32f4xx_usart.c ****   *          software sequence: a read operation to USART_SR register 
1440:FWLIB/src/stm32f4xx_usart.c ****   *          (USART_GetITStatus()) followed by a read operation to USART_DR register 
1441:FWLIB/src/stm32f4xx_usart.c ****   *          (USART_ReceiveData()).
ARM GAS  /tmp/cc0JzPHi.s 			page 50


1442:FWLIB/src/stm32f4xx_usart.c ****   * @note   RXNE pending bit can be also cleared by a read to the USART_DR register 
1443:FWLIB/src/stm32f4xx_usart.c ****   *          (USART_ReceiveData()).
1444:FWLIB/src/stm32f4xx_usart.c ****   * @note   TC pending bit can be also cleared by software sequence: a read 
1445:FWLIB/src/stm32f4xx_usart.c ****   *          operation to USART_SR register (USART_GetITStatus()) followed by a write 
1446:FWLIB/src/stm32f4xx_usart.c ****   *          operation to USART_DR register (USART_SendData()).
1447:FWLIB/src/stm32f4xx_usart.c ****   * @note   TXE pending bit is cleared only by a write to the USART_DR register 
1448:FWLIB/src/stm32f4xx_usart.c ****   *          (USART_SendData()).
1449:FWLIB/src/stm32f4xx_usart.c ****   *  
1450:FWLIB/src/stm32f4xx_usart.c ****   * @retval None
1451:FWLIB/src/stm32f4xx_usart.c ****   */
1452:FWLIB/src/stm32f4xx_usart.c **** void USART_ClearITPendingBit(USART_TypeDef* USARTx, uint16_t USART_IT)
1453:FWLIB/src/stm32f4xx_usart.c **** {
 1375              		.loc 1 1453 0
 1376              		.cfi_startproc
 1377              		@ args = 0, pretend = 0, frame = 0
 1378              		@ frame_needed = 0, uses_anonymous_args = 0
 1379              		@ link register save eliminated.
 1380              	.LVL150:
1454:FWLIB/src/stm32f4xx_usart.c ****   uint16_t bitpos = 0x00, itmask = 0x00;
1455:FWLIB/src/stm32f4xx_usart.c ****   /* Check the parameters */
1456:FWLIB/src/stm32f4xx_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
1457:FWLIB/src/stm32f4xx_usart.c ****   assert_param(IS_USART_CLEAR_IT(USART_IT)); 
1458:FWLIB/src/stm32f4xx_usart.c **** 
1459:FWLIB/src/stm32f4xx_usart.c ****   /* The CTS interrupt is not available for UART4 and UART5 */
1460:FWLIB/src/stm32f4xx_usart.c ****   if (USART_IT == USART_IT_CTS)
1461:FWLIB/src/stm32f4xx_usart.c ****   {
1462:FWLIB/src/stm32f4xx_usart.c ****     assert_param(IS_USART_1236_PERIPH(USARTx));
1463:FWLIB/src/stm32f4xx_usart.c ****   } 
1464:FWLIB/src/stm32f4xx_usart.c ****     
1465:FWLIB/src/stm32f4xx_usart.c ****   bitpos = USART_IT >> 0x08;
 1381              		.loc 1 1465 0
 1382 0000 090A     		lsrs	r1, r1, #8
 1383              	.LVL151:
1466:FWLIB/src/stm32f4xx_usart.c ****   itmask = ((uint16_t)0x01 << (uint16_t)bitpos);
 1384              		.loc 1 1466 0
 1385 0002 0123     		movs	r3, #1
 1386 0004 8B40     		lsls	r3, r3, r1
 1387 0006 9BB2     		uxth	r3, r3
 1388              	.LVL152:
1467:FWLIB/src/stm32f4xx_usart.c ****   USARTx->SR = (uint16_t)~itmask;
 1389              		.loc 1 1467 0
 1390 0008 DB43     		mvns	r3, r3
 1391              	.LVL153:
 1392 000a 9BB2     		uxth	r3, r3
 1393              	.LVL154:
 1394 000c 0380     		strh	r3, [r0]	@ movhi
 1395 000e 7047     		bx	lr
 1396              		.cfi_endproc
 1397              	.LFE151:
 1399              		.text
 1400              	.Letext0:
 1401              		.file 2 "/usr/include/newlib/machine/_default_types.h"
 1402              		.file 3 "/usr/include/newlib/sys/_stdint.h"
 1403              		.file 4 "F4_CORE/core_cm4.h"
 1404              		.file 5 "USER/system_stm32f4xx.h"
 1405              		.file 6 "USER/stm32f4xx.h"
 1406              		.file 7 "FWLIB/inc/stm32f4xx_rcc.h"
ARM GAS  /tmp/cc0JzPHi.s 			page 51


 1407              		.file 8 "FWLIB/inc/stm32f4xx_usart.h"
ARM GAS  /tmp/cc0JzPHi.s 			page 52


DEFINED SYMBOLS
                            *ABS*:0000000000000000 stm32f4xx_usart.c
     /tmp/cc0JzPHi.s:18     .text.USART_DeInit:0000000000000000 $t
     /tmp/cc0JzPHi.s:25     .text.USART_DeInit:0000000000000000 USART_DeInit
     /tmp/cc0JzPHi.s:189    .text.USART_DeInit:00000000000000dc $d
     /tmp/cc0JzPHi.s:201    .text.USART_Init:0000000000000000 $t
     /tmp/cc0JzPHi.s:208    .text.USART_Init:0000000000000000 USART_Init
     /tmp/cc0JzPHi.s:379    .text.USART_Init:00000000000000c8 $d
     /tmp/cc0JzPHi.s:385    .text.USART_StructInit:0000000000000000 $t
     /tmp/cc0JzPHi.s:392    .text.USART_StructInit:0000000000000000 USART_StructInit
     /tmp/cc0JzPHi.s:420    .text.USART_ClockInit:0000000000000000 $t
     /tmp/cc0JzPHi.s:427    .text.USART_ClockInit:0000000000000000 USART_ClockInit
     /tmp/cc0JzPHi.s:476    .text.USART_ClockStructInit:0000000000000000 $t
     /tmp/cc0JzPHi.s:483    .text.USART_ClockStructInit:0000000000000000 USART_ClockStructInit
     /tmp/cc0JzPHi.s:505    .text.USART_Cmd:0000000000000000 $t
     /tmp/cc0JzPHi.s:512    .text.USART_Cmd:0000000000000000 USART_Cmd
     /tmp/cc0JzPHi.s:540    .text.USART_SetPrescaler:0000000000000000 $t
     /tmp/cc0JzPHi.s:547    .text.USART_SetPrescaler:0000000000000000 USART_SetPrescaler
     /tmp/cc0JzPHi.s:570    .text.USART_OverSampling8Cmd:0000000000000000 $t
     /tmp/cc0JzPHi.s:577    .text.USART_OverSampling8Cmd:0000000000000000 USART_OverSampling8Cmd
     /tmp/cc0JzPHi.s:604    .text.USART_OneBitMethodCmd:0000000000000000 $t
     /tmp/cc0JzPHi.s:611    .text.USART_OneBitMethodCmd:0000000000000000 USART_OneBitMethodCmd
     /tmp/cc0JzPHi.s:639    .text.USART_SendData:0000000000000000 $t
     /tmp/cc0JzPHi.s:646    .text.USART_SendData:0000000000000000 USART_SendData
     /tmp/cc0JzPHi.s:663    .text.USART_ReceiveData:0000000000000000 $t
     /tmp/cc0JzPHi.s:670    .text.USART_ReceiveData:0000000000000000 USART_ReceiveData
     /tmp/cc0JzPHi.s:688    .text.USART_SetAddress:0000000000000000 $t
     /tmp/cc0JzPHi.s:695    .text.USART_SetAddress:0000000000000000 USART_SetAddress
     /tmp/cc0JzPHi.s:720    .text.USART_ReceiverWakeUpCmd:0000000000000000 $t
     /tmp/cc0JzPHi.s:727    .text.USART_ReceiverWakeUpCmd:0000000000000000 USART_ReceiverWakeUpCmd
     /tmp/cc0JzPHi.s:755    .text.USART_WakeUpConfig:0000000000000000 $t
     /tmp/cc0JzPHi.s:762    .text.USART_WakeUpConfig:0000000000000000 USART_WakeUpConfig
     /tmp/cc0JzPHi.s:787    .text.USART_LINBreakDetectLengthConfig:0000000000000000 $t
     /tmp/cc0JzPHi.s:794    .text.USART_LINBreakDetectLengthConfig:0000000000000000 USART_LINBreakDetectLengthConfig
     /tmp/cc0JzPHi.s:819    .text.USART_LINCmd:0000000000000000 $t
     /tmp/cc0JzPHi.s:826    .text.USART_LINCmd:0000000000000000 USART_LINCmd
     /tmp/cc0JzPHi.s:854    .text.USART_SendBreak:0000000000000000 $t
     /tmp/cc0JzPHi.s:861    .text.USART_SendBreak:0000000000000000 USART_SendBreak
     /tmp/cc0JzPHi.s:879    .text.USART_HalfDuplexCmd:0000000000000000 $t
     /tmp/cc0JzPHi.s:886    .text.USART_HalfDuplexCmd:0000000000000000 USART_HalfDuplexCmd
     /tmp/cc0JzPHi.s:914    .text.USART_SetGuardTime:0000000000000000 $t
     /tmp/cc0JzPHi.s:921    .text.USART_SetGuardTime:0000000000000000 USART_SetGuardTime
     /tmp/cc0JzPHi.s:944    .text.USART_SmartCardCmd:0000000000000000 $t
     /tmp/cc0JzPHi.s:951    .text.USART_SmartCardCmd:0000000000000000 USART_SmartCardCmd
     /tmp/cc0JzPHi.s:979    .text.USART_SmartCardNACKCmd:0000000000000000 $t
     /tmp/cc0JzPHi.s:986    .text.USART_SmartCardNACKCmd:0000000000000000 USART_SmartCardNACKCmd
     /tmp/cc0JzPHi.s:1014   .text.USART_IrDAConfig:0000000000000000 $t
     /tmp/cc0JzPHi.s:1021   .text.USART_IrDAConfig:0000000000000000 USART_IrDAConfig
     /tmp/cc0JzPHi.s:1046   .text.USART_IrDACmd:0000000000000000 $t
     /tmp/cc0JzPHi.s:1053   .text.USART_IrDACmd:0000000000000000 USART_IrDACmd
     /tmp/cc0JzPHi.s:1081   .text.USART_DMACmd:0000000000000000 $t
     /tmp/cc0JzPHi.s:1088   .text.USART_DMACmd:0000000000000000 USART_DMACmd
     /tmp/cc0JzPHi.s:1119   .text.USART_ITConfig:0000000000000000 $t
     /tmp/cc0JzPHi.s:1126   .text.USART_ITConfig:0000000000000000 USART_ITConfig
     /tmp/cc0JzPHi.s:1201   .text.USART_GetFlagStatus:0000000000000000 $t
     /tmp/cc0JzPHi.s:1208   .text.USART_GetFlagStatus:0000000000000000 USART_GetFlagStatus
     /tmp/cc0JzPHi.s:1235   .text.USART_ClearFlag:0000000000000000 $t
ARM GAS  /tmp/cc0JzPHi.s 			page 53


     /tmp/cc0JzPHi.s:1242   .text.USART_ClearFlag:0000000000000000 USART_ClearFlag
     /tmp/cc0JzPHi.s:1260   .text.USART_GetITStatus:0000000000000000 $t
     /tmp/cc0JzPHi.s:1267   .text.USART_GetITStatus:0000000000000000 USART_GetITStatus
     /tmp/cc0JzPHi.s:1366   .text.USART_ClearITPendingBit:0000000000000000 $t
     /tmp/cc0JzPHi.s:1373   .text.USART_ClearITPendingBit:0000000000000000 USART_ClearITPendingBit
                     .debug_frame:0000000000000010 $d

UNDEFINED SYMBOLS
RCC_APB2PeriphResetCmd
RCC_APB1PeriphResetCmd
RCC_GetClocksFreq
